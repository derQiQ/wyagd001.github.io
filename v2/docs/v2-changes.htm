<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>自 v1.1 来的更改 | AutoHotkey v2</title>
<meta name="description" content="Changes between v1.1 and v2.0." />
<meta name="ahk:equiv-v1" content="AHKL_ChangeLog.htm" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script type="text/javascript">$(function(){0<=window.navigator.userAgent.toLowerCase().indexOf("ucbrowser")&&CaoNiMaDeUc()})</script>
</head>
<body>
<h1>v1.1 到 v2.0 的更改</h1>

<h2 id="toc">目录</h2>
<p><strong><a href="#language">语言</a></strong></p>
<ul>
  <li><a href="#legacy-syntax-removed">已删除旧式语法</a></li>
  <li><a href="#hotkey-and-hotstring-labels">热键和热字串标签</a></li>
  <li><a href="#names">名称</a></li>
  <li><a href="#scope">作用域</a></li>
  <li><a href="#variables">变量</a></li>
  <li><a href="#expressions">表达式</a></li>
  <li><a href="#objects-misc">对象(其他)</a></li>
  <li><a href="#functions">函数</a></li>
  <li><a href="#nested-functions">套嵌函数</a></li>
  <li><a href="#uncategorized">未分类</a></li>
  <li><a href="#continuation-sections">延续片段</a></li>
  <li><a href="#continuation-lines">延续行</a></li>
  <li><a href="#types">类型</a></li>
</ul>
<p><strong><a href="#objects">对象</a></strong></p>
<ul>
  <li><a href="#primitive-values">原始值</a></li>
  <li><a href="#properties-and-methods">属性和方法</a></li>
  <li><a href="#staticclass-variables">静态变量</a></li>
  <li><a href="#meta-functions">元函数</a></li>
  <li><a href="#array">数组</a></li>
  <li><a href="#map">Map</a></li>
  <li><a href="#enumeration">枚举器</a></li>
  <li><a href="#bound-functions">函数</a></li>
  <li><a href="#com-objects-comobject">COM 对象(ComObject)</a></li>
  <li><a href="#default-property">默认属性</a></li>
  <li><a href="#com-calls">Com Calls</a></li>
</ul>
<p><strong><a href="#library">库</a></strong></p>
<ul>
  <li><a href="#modified-commandsfunctions">修改的命令/函数</a></li>
  <li><a href="#new-functions">新函数</a></li>
  <li><a href="#staticclass-variables">Static/Class 变量</a></li>
  <li><a href="#new-directives">新指令</a></li>
  <li><a href="#built-in-variables">内置变量</a></li>
  <li><a href="#built-in-objects">内置对象</a></li>
</ul>
<p><strong><a href="#gui">Gui</a></strong></p>
<ul>
  <li><a href="#gui-sub-commands">Gui 子命令</a></li>
  <li><a href="#events">事件</a></li>
  <li><a href="#removed">删除的</a></li>
  <li><a href="#control-options">控件选项</a></li>
  <li><a href="#guicontrolget">GuiControlGet</a></li>
  <li><a href="#guicontrol">GuiControl</a></li>
  <li><a href="#other-changes">其他更改</a></li>
</ul>
<p><strong><a href="#error-handling">错误处理</a></strong></p>
<ul>
  <li><a href="#continuable-errors">可继续错误</a></li>
  <li><a href="#errorlevel">ErrorLevel</a></li>
  <li><a href="#expressions-1">表达式</a></li>
  <li><a href="#functions-1">函数</a></li>
  <li><a href="#catch">Catch</a></li>
</ul>
<p><strong><a href="#keyboard-mouse-hotkeys-and-hotstrings">键盘, 鼠标, 热键和热字串</a></strong></p>
<p><strong><a href="#other">其他</a></strong></p>
<ul>
  <li><a href="#persistence">持续运行</a></li>
  <li><a href="#threads">线程</a></li>
  <li><a href="#default-settings">默认设置</a></li>
  <li><a href="#command-line">命令行</a></li>
</ul>

<h2 id="language">语言</h2>
<h3 id="legacy-syntax-removed">已删除旧式语法</h3>
<p>删除原义(文本) 赋值: <code>var = value</code></p>
<p>删除了所有旧式 If 语句, 仅保留 <code>if 表达式</code>, 它从不要求有括号(但允许有括号, 就像在任何表达式中一样).</p>
<p>删除 "命令语法". 已经没有了 "命令", 只有 <a href="Language.htm#function-call-statements"><em>函数调用语句</em></a>, 它们只是没有括号的函数或方法调用. 这意味着:</p>
<ul>
<li>所有以前的命令现在都是函数(不包括控制流语句).</li>
<li>如果不需要返回值, 所有的函数都可以不带括号调用(但是和以前一样, 表达式内的调用不能省略括号).</li>
<li>所有参数都是表达式, 因此所有文本都是 "带引号的", 逗号不需要转义. 目前这不包括一些指令(它们既不是命令也不是函数).</li>
<li>不管是否有括号, 参数都是一样的; 也就是说, 返回值没有输出变量, 因此如果省略括号, 它将被丢弃.</li>
<li>正常的变量引用从不用百分号括起来(除了 <a href="commands/_Include.htm">#Include</a> 和 <a href="commands/_DllLoad.htm">#DllLoad</a>). 使用<a href="Variables.htm#concat">连接</a>或 <a href="commands/Format.htm">Format</a> 来包含文本中的变量.</li>
<li>在函数名和参数之间没有逗号, 所以 <code>MouseGetPos(, y)</code> = <code>MouseGetPos , y</code> (省略 x). 为了清楚起见, 需要一个空格或制表符. 为了保持一致性, 指令也遵循新的约定(指令名称和参数之间不能有逗号).</li>
<li>没有百分号-空格前缀来强制表达式. 表达式中没有引号的百分号只用于双解引/动态引用, 有奇数个百分号是一个语法错误.</li>
<li>方法调用语句(省略括号的方法调用) 被限制为一个普通的变量, 后面跟着一个或多个用点分隔的标识符, 如 <code>MyVar.MyProperty.MyMethod "String to pass"</code>.</li>
</ul>
<p>从 v1 命令到函数的转换通常如下所示(但有些函数已经改变了, 下文会进一步说明):</p>
<ul>
<li>如果命令的第一个参数是一个输出变量, 而第二个参数不是, 它就会成为返回值, 并从参数列表中删除.</li>
<li>其余的输出变量的处理方式与 <a href="#byref">ByRef 参数</a>类似(其用法和语法已经改变), 只是它们允许引用可写的内置变量.</li>
<li>失败时抛出异常, 而不是设置 ErrorLevel.</li>
<li>以前通过 ErrorLevel 返回的值会通过其他方式返回, 替换为异常, 作废或者无返回值.</li>
</ul>
<p>所有控制流语句也接受表达式, 除了下面提到的.</p>
<p>所有带参数的控制流语句(目前不包括两个单词的 Loop 语句) 都支持小括号包围其参数列表, 名称和小括号之间没有任何空格. 例如, <code>return(var)</code>. 但是, 这些不是函数; 例如, <code>x := return(y)</code> 是无效的. <a href="commands/If.htm">If</a> 和 <a href="commands/While.htm">While</a> 已经支持这个.</p>
<p><a href="#loop-sub-commands">Loop</a>(除了 <a href="commands/Loop.htm">Loop <em>Count</em></a>) 后面现在有一个次要的关键字(Files, Parse, Read 或 Reg), 它不能被 "括起来" 或被变量包含. 目前, 关键字后面可以有一个逗号, 但这不是必须的, 因为这不是一个参数. OTB 被所有模式所支持.</p>
<p><a href="commands/Goto.htm">Goto</a>, <a href="commands/Break.htm">break</a> 和 <a href="commands/Continue.htm">continue</a> 需要一个没有引号的标签名, 类似于 v1(<code>goto label</code> 跳转到 <code>label:</code>). 要动态地跳转到一个标签, 请在名称后面使用圆括号: <code>goto(expression)</code>. 然而, 这不是一个函数, 不能在表达式中间使用. 圆括号可以与 break 或 continue 一起使用, 但在这种情况下, 参数必须是一个单一的原义数字或带引号的字符串.</p>
<p>Gosub 已被删除, 标签也不能再与 <a href="commands/SetTimer.htm">SetTimer</a> 和 <a href="commands/Hotkey.htm">Hotkey</a> 等函数一起使用.</p>
<ul>
<li>它们是多余的; 基本上只是一种有限的函数形式, 没有局部变量或返回值, 而且是在它们自己的独立命名空间中. 函数可以在以前使用标签子程序的任何地方使用(甚至<a href="Functions.htm#nested">在其他函数内部</a>).</li>
<li>函数不能重叠(但可以包含在一个函数中). 相反, 可以使用多个函数, 并从其他函数中调用. 使用函数参数取代 A_ThisLabel.</li>
<li>与子程序不同, 如果忘记定义函数的 <em>结尾</em>, 通常会被提醒错误, 因为每个 <code>{</code> 必须有一个相应的 <code>}</code>. 与标签子程序相比, 识别一个函数的边界可能也更容易.</li>
<li>函数可以放在自动执行部分而不中断它. 自动执行部分现在可以很容易地跨越整个脚本, 所以可以改称为<a href="Language.htm#global-code">全局代码</a>, 在<a href="Scripts.htm#auto">自动执行线程</a>中执行.</li>
<li>函数可能不太容易像 "goto" 一样被误用(用户循环跳转到当前子程序(循环子程序本身), 不可避免地耗尽堆栈空间并终止程序).</li>
<li>如果没有接受标签或函数的函数(如 <a href="commands/Hotkey.htm">Hotkey</a>), 就不会有那么多的歧义, 因为两者可以同时以相同的名称存在.</li>
<li>对于标签的所有其余用途, 从一个函数内部引用一个全局标签是无效的. 因此, 标签查找可以被限制在局部标签列表中. 因此, 没有必要检查从函数内部到外部的无效跳转(从未支持过).</li>
</ul>
<h3 id="hotkey-and-hotstring-labels">热键和热字串标签</h3>
<p><a href="Hotkeys.htm">热键</a>和非自动替换<a href="Hotstrings.htm">热字串</a>不再是标签; 相反, 它们(自动) 定义了一个函数. 对于多行热键, 使用大括号将热键的主体括起来, 而不是用 <code>return</code>(其是隐式的大括号的结束) 终止它. 要允许显式调用一个热键, 在 <code>::</code> 和 <code>{</code> 之间指定 <code>funcName(ThisHotkey)</code> - 这在 v1.1.20+ 中也可以做到, 但现在有一个参数. 当函数定义不是显式的时, 参数被命名为 ThisHotkey.</p>
<p><strong>注意:</strong> 热键函数默认是<a href="Functions.htm#AssumeLocal">假定-局部</a>的, 因此在没有声明的情况下不能赋值给<a href="Functions.htm#Global">全局变量</a>.</p>
<h3 id="names">名称</h3>
<p>现在, 函数和变量名被放在一个共享的命名空间中.</p>
<ul>
<li>每个函数定义在当前空间内创建一个常量(只读变量).</li>
<li>使用 <code>MyFunc</code> 代替 <code>Func("MyFunc")</code>.</li>
<li>当把函数传递给任何内置函数如 <a href="commands/SetTimer.htm">SetTimer</a> 或 <a href="commands/Hotkey.htm">Hotkey</a> 时, 使用 <code>MyFunc</code> 代替 <code>"MyFunc"</code>. 不再支持传递名称(字符串).</li>
<li>当按值调用函数时, 使用 <code>myVar()</code> 代替 <code>%myVar%()</code>.</li>
<li>当你只有一个函数名(字符串) 时, 要调用一个函数, 首先要使用一个<a href="Variables.htm#deref">双解引</a>将名称解析为一个变量并检索其值(函数对象). <code>%myVar%()</code> 现在实际上是执行了一个双解引, 然后调用结果, 等同于 <code>f := %myVar%, f()</code>. 尽可能避免按名称(字符串) 来处理函数; 使用引用来代替.</li>
<pre><em>; 译者注: 添加一个 v2 示例来进行说明</em>
myvar  := f
myvar2 := "f"
msgbox myvar(1,2)    ; 显示结果 3
msgbox %myvar2%(1,2) ; 显示结果 3

f(a,b)
{
return a+b
}
</pre>
</ul>
<p>名称不能以数字开头, 也不能包含以前允许的下列字符: <code>@ # $</code>. 只允许使用字母, 数字, 下划线和非 ASCII 字符.</p>
<p><strong>保留关键字:</strong> 声明关键字和控制流语句的名称不能作为变量, 函数或类的名称. 这包括 <code class="no-highlight">local</code>, <code class="no-highlight">global</code>, <code class="no-highlight">static</code>, <code class="no-highlight">if</code>, <code class="no-highlight">else</code>, <code class="no-highlight">loop</code>, <code class="no-highlight">for</code>, <code class="no-highlight">while</code>, <code class="no-highlight">until</code>, <code class="no-highlight">break</code>, <code class="no-highlight">continue</code>, <code class="no-highlight">goto</code>, <code class="no-highlight">return</code>, <code class="no-highlight">switch</code>, <code class="no-highlight">case</code>, <code class="no-highlight">try</code>, <code class="no-highlight">catch</code>, <code class="no-highlight">finally</code> 和 <code class="no-highlight">throw</code>. 这样做的主要目的是为了检测错误, 如 <code>if (ex) break</code>.</p>
<p><strong>保留关键字:</strong> <code class="no-highlight">as</code>, <code class="no-highlight">and</code>, <code class="no-highlight">contains</code>, <code class="no-highlight">false</code>, <code class="no-highlight">in</code>, <code class="no-highlight">is</code>, <code class="no-highlight">IsSet</code>, <code class="no-highlight">not</code>, <code class="no-highlight">or</code>, <code class="no-highlight">super</code>, <code class="no-highlight">true</code>, <code class="no-highlight">unset</code>. 这些词是为将来使用或其他特定目的而保留的, 即使没有歧义, 也不允许作为变量或函数名. 这主要是为了保持一致性: 在 v1 版本中, <code>and := 1</code> 被允许放在单独的行中, 但 <code>(and := 1)</code> 就不行了.</p>
<p>上面列出的词被允许作为属性或窗口组名称. 典型使用的属性名称前面都有 <code>.</code>, 这可以防止该词被解释为运算符. 相比之下, 关键字永远不会被解释为表达式中的变量或函数名. 例如, <code>not(x)</code> 等同于 <code>not (x)</code> 或 <code>(not x)</code>.</p>
<p>许多类是预定义的, 与用户定义的类的方式相同, 这有效地保留了这些全局变量名. (然而, 下面描述的<a href="#scope">域的变更</a>缓解了由此产生的大部分问题.) 关于类的列表, 请参阅<a href="objects/index.htm">内置的类</a>.</p>
<h3 id="scope">作用域</h3>
<p><em>超级-全局</em> 已被删除(不包括内置变量, 因为它们不能被重新声明或隐藏, 所以不完全一样).</p>
<p>在<a href="Functions.htm#AssumeLocal">假定-局部</a>函数中, 如果给定的名称没有在声明中使用, 也没有作为非动态赋值或<a href="Variables.htm#ref">引用(&amp;) 运算符</a>的目标, 则它可能解析为一个现有的全局变量.</p>
<p>换句话说:</p>
<ul>
<li>函数现在可以在不声明的情况下读取全局变量.</li>
<li>没有 <code>global</code> 声明的函数不能直接修改全局变量(消除了意外副作用的一个来源).</li>
<li>在脚本中添加一个新的 <code>class</code>, 不太可能影响任何现有函数的行为, 因为类不是超全局的.</li>
<li><code>global</code> 关键字目前在全局范围内使用时是多余的, 但为了清晰起见可以使用. 这样声明的变量现在不太可能与局部变量发生冲突(比如在手动组合脚本或使用 <a href="commands/_Include.htm">#Include</a> 时), 因为它们不是超全局的. 另一方面, 也失去了一些便利.</li>
<li>声明通常不需要那么多.</li>
</ul>
<p><em>强制-局部</em> 模式已被删除.</p>
<h3 id="variables">变量</h3>
<p>局部 <a href="Functions.htm#static">static</a> 变量在执行到它们时被初始化, 而不是在自动执行部分开始前按线性顺序执行. 每个初始化器在第二次到达时没有效果. 多个声明是允许的, 并且可以在不同时间为同一个变量执行. 这有多种好处:</p>
<ul>
<li>当静态初始化器用静态变量调用其他函数时, 由于函数定义的顺序, 初始化器尚未执行的风险较小.</li>
<li>因为函数已经被调用, 所以参数, <a href="Variables.htm#ThisFunc">A_ThisFunc</a> 和闭包都是可用的(以前不可用).</li>
<li>静态变量可以被有条件地初始化, 增加了灵活性, 同时仍然只执行一次, 不需要 <code>if IsSet()</code>.</li>
<li>由于一个静态变量可能有多个初始化器, 所以允许联合赋值, 如 <code>static x += 1</code>. (这个改变稍微减少了代码的大小, 因为它已经被 <code>local</code> 和 <code>global</code> 所允许.)</li>
</ul>
<p class="note"><strong>注意:</strong> <code>static init := somefunction()</code> 不能再用于自动执行 <em>somefunction</em>. 然而, 由于现在可以完全避免基于标签和返回的子程序, 因此自动执行部分能够跨越整个脚本.</p>
<p>使用 <code>local</code> 声明一个变量不再使函数<a href="Functions.htm#AssumeGlobal">假定-全局</a>.</p>
<p><a href="Variables.htm#deref">双重引用</a>现在与加载时解析的变量更加一致, 不再能够创建新的变量. 这避免了一些不一致的地方和常见的混淆点.</p>
<p>由于任何原因而失败的双重引用现在会抛出错误. 以前, 任何具有无效名称的情况都会默默地产生一个空字符串, 而其他情况会创建并返回一个空变量.</p>
<h3 id="expressions">表达式</h3>
<p>带引号的原义字符串可以用  <code>"双引号"</code> 或 <code>'单引号'</code> 书写, 但必须以相同的引号开始和结束. 原义引号的写法是在引号前加一个转义字符 - <code>`"</code> 或 <code>`'</code> - 或者使用相反类型的引号: <code>'"42" is the answer'</code>. 双重引号没有特殊意义, 而且会导致错误, 因为自动串联需要一个空格.</p>
<p>运算符 <code>&amp;&amp;</code>, <code>||</code>, <code>and</code> 和 <code>or</code> 产生的值取决于结果, 与 JavaScript 和 Lua 类似. 例如, <code>"" or "default"</code> 产生 <code>"default"</code> 而不是 <code>1</code>. 需要纯布尔值(0 或 1) 的脚本可以使用类似 <code>!!(x or y)</code> 或 <code>(x or y) ? 1 : 0</code> 语句.</p>
<p>自动连接(串联) 现在要求在所有情况下至少有一个空格或制表符(v1 版的文档说 "应该有" 一个空格).</p>
<p>像 <code>x(), y()</code> 这样的多语句表达式的结果是最后一个(最右边) 子表达式, 而不是第一个(最左边的) 子表达式. 在 v1 和 v2 中, 子表达式是按从左到右的顺序计算的.</p>
<p>逗号后的等号不再是赋值: 在 <code>x:=y, y=z</code> 中的 <code>y=z</code> 是一个无效的比较而不是赋值.</p>
<p><code>:= += -= *= /= ++ --</code> 具有一致的行为, 无论它们是单独使用还是与其他运算符结合使用, 例如 <code>x := y, y += 2</code>. 以前, 当表达式中出现错误或在数学运算中使用空白值时, 会出现不同的行为.</p>
<p><code>!=</code> 现在总是不区分大小写的, 就像 <code>=</code> 一样, 而 <code>!==</code> 已经被添加为 <code>==</code> 的对应词.</p>
<p><code>&lt;&gt;</code> 已被删除.</p>
<p>如果给定的是一个浮点数字, <code>//</code> 现在会抛出异常. 以前, 负浮点数和负整数之间的结果是不一致的.</p>
<p>现在如果给定的是浮点数, <code>|</code>, <code>^</code>, <code>&amp;</code>, <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 现在会抛出异常, 而不是截断为整数.</p>
<p>科学记数法可以在没有小数点的情况下使用(但还是会产生一个浮点数). 当数字字符串被转换为整数时, 也支持科学符号(例如, "1e3" 被解释为 1000 而不是 1).</p>
<p>函数调用现在几乎允许任何子表达式来指定要调用的函数, 只要在参数列表的开括号前没有空格或制表符. 例如, <code>MyFunc()</code> 将调用 <code>MyFunc</code> 不管它是函数的实际名称还是包含函数对象的变量, 而 <code>(a?b:c)()</code> 将根据 <code>a</code> 调用 <code>b</code> 或 <code>c</code>. 注意 <code>x.y()</code> 仍然是一个方法调用, 大致相当于 <code>(x.y)(x)</code>, 但 <code>a[i]()</code> 现在相当于 <code>(a[i])()</code>.</p>
<p>双重引用现在几乎允许任何表达式 (不仅仅是变量) 作为变量名的来源. 例如, <code>DoNotUseArray%n+1%</code> 和 <code>%(%triple%)%</code> 都是有效的. 双重引用语法现在也被用来解除对 VarRefs 的引用, 例如 <code>ref := &amp;var, value := %ref%</code>.</p>
<p>表达式 <code>funcName[""]()</code> 和 <code>funcName.()</code> 不再按名称调用一个函数. 省略 <code>.()</code> 中的方法名称现在会导致加载时的错误信息. 函数应该通过引用来调用或处理, 而不是通过名字.</p>
<p><code>var :=</code> 没有 r-值时, 在加载时被视为错误. 在 v1 版中, 它相当于 <code>var := ""</code>, 但如果与另一个表达式结合使用, 就会静默失败 - 例如: <code>x :=, y :=</code>.</p>
<p>当一个原义字符串后面跟了一个不确定的一元/二元运算符时, 在加载时就会报告错误. 例如, <code>"new counter:" ++counter</code> 可能应该是递增和显示 <code>counter</code>, 但从技术上讲, 它是无效的 <em>addition</em> 和 <em>unary plus</em>.</p>
<p><code>word ++</code> 和 <code>word --</code> 不再是表达式, 因为 <code>word</code> 可以是一个用户定义的函数(而且 ++/- 后面可能有一个表达式, 产生一个变量引用). 要写一个独立的后增量或后减量表达式, 要么省略变量和运算符之间的空格, 要么用括号包住变量或表达式.</p>
<p><code>word ? x : y</code> 仍然是一个三元表达式, 但是以单词开头的更复杂的情况, 如 <code>word1 word2 ? x : y</code>, 总是被解释为对 <em>word1</em> 的函数调用(即使不存在这样的函数). 要写一个具有复杂条件的独立的三元表达式, 请将条件放在括号里.</p>
<p>新的 <a href="Variables.htm#is"><code>is</code> 运算符</a>, 如 <code>x is y</code> 可以用来检查值 <em>x</em> 是否是类 <em>y</em> 的实例, <em>y</em> 必须是一个具有 <code>prototype</code> 属性的对象(即一个类). 这包括原始值, 如 <code>x is Integer</code>(这严格来说是一种类型检查, 而 <code>IsInteger(x)</code> 检查的是潜在的转换).</p>
<p>关键词 <code>contains</code> 和 <code>in</code> 被保留下来供将来使用.</p>
<p><code>&amp;var</code>(取址) 已被 <code>StrPtr(var)</code> 和 <code>ObjPtr(obj)</code> 取代, 以更清楚地显示意图并加强错误检查. 在 v1 中, 取址返回 <em>var</em> 内部字符串缓冲的地址, 即使它包含一个数字(但不是一个对象). 它还用于检索一个对象的地址, 而得到一个错误类型的地址会产生可怕的后果.</p>
<p><code>&amp;var</code> 现在是<a href="Variables.htm#ref">引用运算符</a>, 它与所有的 <a href="#byref">ByRef</a> 和 OutputVar 参数一起使用, 以提高清晰度和灵活性(并使其他语言变化成为可能). 有关详情, 请参阅<a href="Concepts.htm#variable-references">变量引用(VarRef)</a>.</p>
<p>字符串长度现在在表达式计算期间被缓存. 这提高了性能, 并允许字符串包含二进制零. 特别是:</p>
<ul>
<li>两个字符串的串联, 其中一个或两个都包含二进制零, 不再导致数据的截断.</li>
<li>区分大小写的等号运算符(<code>==</code> 和 <code>!==</code>) 可以用来比较二进制数据. 其他比较运算符只能 "看到" 第一个二进制零.</li>
<li>二进制数据可以从函数返回并分配给对象.</li>
</ul>
<p>大多数函数仍然期待空终止字符串, 所以只能 "看到" 第一个二进制零. 例如, <a href="commands/MsgBox.htm">MsgBox</a> 将只显示第一个二进制 0 之前的字符串部分.</p>
<p><code>*</code>(deref) 运算符已经被删除. 请使用 <a href="commands/NumGet.htm">NumGet</a> 代替.</p>
<p><code>~</code>(<a href="Variables.htm#unary">bitwise-NOT</a>) 运算符现在总是将其输入作为 64 位有符号整数处理; 它不再将 0 到 4294967295 之间的值作为无符号 32 位处理.</p>
<p>新增 <code>&gt;&gt;&gt;</code> 和 <code>&gt;&gt;&gt;=</code> 用于逻辑右位移.</p>
<p>新增 <a href="Variables.htm#fat-arrow">胖箭头函数</a>. 表达式 <code>Fn(Parameters) =&gt; Expression</code> 定义了一个名为 <em>Fn</em> 的函数(可以是空白), 并返回一个 <a href="objects/Func.htm">Func</a> 或闭包对象. 当调用时, 该函数计算 <em>Expression</em> 并返回结果. 当在另一个函数中使用时, <em>Expression</em> 可以引用外层函数的变量(这也可以通过普通的函数定义来实现).</p>
<p>胖箭头语法也可以用来定义方法和属性的获取器/设置器(在这种情况下, 方法/属性定义本身并不是一个表达式, 但其主体只是返回一个表达式).</p>
<p>在成员访问的左侧, 现在完全支持原义数字(点). 例如, <code>0.1</code> 是一个数字, 但 <code>0.min</code> 和 <code>0.1.min</code> 访问的是 <em>min</em> 属性, 这可以由一个基对象来处理(请参阅<a href="Objects.htm#primitive">原始值</a>). <code>1..2</code> 或 <code>1.0.2</code> 是数字 1.0, 后面是属性 2. 使用实例可能是实现测量单位, 原义版本号或范围.</p>
<p><code>x**y</code>: 当 <code>x</code> 和 <code>y</code> 时整数, 并且 <code>y</code> 是正数, 如果在范围内, 幂运算符现在对所有输入都给出正确的结果, 以前由于内部使用浮点数, 一些精度会丢失. 溢出的行为未被定义.</p>
<h3 id="objects-misc">对象(杂项)</h3>
<p>另请参阅: <a href="#objects">对象</a></p>
<p>现在, 使用 <code>.</code> 访问属性和使用 <code>[]</code> 访问数据(项, 数组和 Map 元素) 之间有了区别. 例如, <code>dictionary["Count"]</code> 可以返回 "Count" 的定义, 而 <code>dictionary.Count</code> 返回其中包含的单词数. 用户定义的对象可以通过定义 <a href="Objects.htm#__Item">__Item 属性</a>来利用这一点.</p>
<p>如果事先不知道属性或方法的名称, 可以(而且必须) 用百分号来访问它. 例如, <code>obj.%varname%()</code> 是 <code>obj[varname]()</code> 的 v2 等价物. <code>[]</code> 的使用是为数据(如数组元素) 保留的.</p>
<p>构造专用对象的原义语法基本上仍然是 <code>{name: value}</code>, 但由于普通对象现在只有 "属性" 而不是 "数组元素", 为了与在其他情况下访问属性的方式保持一致, 规则略有改变:</p>
<ul>
<li><code>o := {a: b}</code> 和以前一样使用名称 "a".</li>
<li><code>o := {%a%: b}</code> 使用 <code>a</code> 的值作为属性名而不是将其作为一个变量名, 执行双重解引并使用结果变量的内容. 换句话说, 它与 <code>o := {}, o.%a% := b</code> 的效果相同.</li>
<pre><em>; 译者注: 添加一个 v2 示例来进行说明</em>
Var  := "abc"
Val  := 123
Obj  := {%Var%: Val}
Obj2 := {Var: Val}
Msgbox  Obj.abc  ; 显示结果 123
Msgbox Obj2.Var  ; 显示结果 123
</pre>
<li>在 <code>:</code> 左边的任何其他类型的表达式都是非法的. 例如, <code>{(a): b}</code> 或 <code>{an error: 1}</code>.</li>
</ul>
<p><code>base.Method()</code> 中的单词 "base" 的使用被替换为 <a href="Objects.htm#Custom_Classes_super">super</a>(<code>super.Method()</code>), 以更好地区分这两个概念:</p>
<ul>
<li><code>super.</code> 或 <code>super[</code> 调用方法/属性的超类版本, 其中 "super-class" 是最初与当前函数定义相关联的原型对象的基.</li>
<li><code>super</code> 是一个保留关键字; 试图在没有 <code>.</code> 或 <code>[</code> 或 <code>(</code> 后缀的情况下使用它, 或者在一个类之外使用, 会导致加载时错误.</li>
<li><code>base</code> 是一个预定义的属性, 用于获取或设置对象的直接基对象(如 <a href="objects/Any.htm#GetBase">ObjGetBase</a>/<a href="objects/Object.htm#SetBase">ObjSetBase</a>). 它只是一个普通的属性名, 而不是保留的.</li>
<li>当超类没有定义 x 时, 调用<code>super.x</code> 会产生一个错误, 而以前 <code>base.x</code> 是被忽略的(即使它是一个赋值).</li>
</ul>
<p>当 Fn 是一个对象时, <code>Fn()</code>(以前写成 <code>%Fn%()</code>) 现在调用  <code>Fn.Call()</code> 而不是 <code>Fn.()</code>(现在只能写成 <code>Fn.%""%()</code>). 函数不再支持没有名称的方法.</p>
<p><code>this.Method()</code> 调用 <code>Fn.Call(this)</code>(其中 <em>Fn</em> 是实现该方法的函数对象) 而不是 <code>Fn[this]()</code>(在 v1 中, 这将导致调用 <code>Fn.__Call(this)</code> 除非 <code>Fn[this]</code> 包含一个函数). 函数对象应该实现一个 <em>Call</em> 方法, 而不是 <em>__Call</em>, 后者只用于显式方法调用.</p>
<p>如果定义了 <code>__New</code>  方法但无法调用它(例如因为参数计数不正确), 或者如果传递了参数但没有定义 <code>__New</code>, <code><i>Classname</i>()</code>(以前的 <code>new <i>Classname</i>()</code>) 现在不能创建对象.</p>
<p>在表达式中创建的对象或从函数返回的对象现在被保留到表达式计算完成, 然后释放. 这稍微提高了性能, 并允许在表达式中使用临时对象进行内存管理, 而不必担心对象被过早释放.</p>
<p>对象可以包含包含二进制零的字符串值(但不是键). 克隆对象可以保留字符串中的二进制数据, 最多可以保留字符串的存储长度(而不是其容量). 历史上, 在处理二进制数据或结构时, 写入的数据超过值的长度; 现在, 应该使用 <a href="objects/Buffer.htm">Buffer</a> 对象来代替.</p>
<p>诸如 <code>x.y := z</code> 这样的赋值表达式现在总是产生 <code>z</code> 的值, 不管 <code>x.y</code> 是如何实现的. 属性设置器的返回值现在被忽略了. 以前是这样:</p>
<ul>
<li>一些内置对象返回 <code>z</code>, 一些返回 <code>x.y</code>(如 <code>c := GuiObj.BackColor := "red"</code> 设置 <code>c</code> 为 <code>0xFF0000</code>), 还有一些返回不正确的值.</li>
<li>用户定义的属性设置器可能返回了意外值或无法返回任何内容.</li>
</ul>
<p><code>x.y(z) := v</code> 现在是一个语法错误. 此前, 它等同于 <code>x.y[z] := v</code>. 一般来说, <code>x.y(z)</code>(方法调用) 和 <code>x.y[z]</code>(参数化属性) 是两个不同的操作, 尽管如果 <code>x</code> 是一个 COM 对象, 它们可能是等同的(由于 COM 接口的限制).</p>
<p>将一个对象与另一个值串联或传递给 Loop, 目前被视为一个错误, 而以前该对象被视为一个空字符串. 这可能会更改为隐式调用 <code>.ToString()</code>. 使用 <code>String(x)</code> 将一个值转换为一个字符串; 如果 <code>x</code> 是一个对象, 这将调用 <code>.ToString()</code>.</p>
<p>当一个对象通过 IDispatch(COM 接口) 被调用时, 任何不能被传回给调用者的未捕获的异常将导致错误对话框. (调用者可能会也可能不会在没有任何具体细节的情况下显示额外错误对话框). 这也适用于由于使用 <a href="commands/ComObjConnect.htm">ComObjConnect</a> 而被调用的事件处理程序.</p>
<h3 id="functions">函数</h3>
<p>函数不能再以超过其正式接受的参数来动态调用.</p>
<p>可变函数不受上述限制的影响, 但通常会在每次调用时创建一个数组来保存多余的参数. 如果不需要这个数组, 现在可以省略参数名以防止它被创建:</p>
<pre>AcceptsOneOrMoreArgs(first, *) {
  ...
}
</pre>
<p>这可以用于不需要额外参数的回调.</p>
<p>可变函数调用现在允许任何可枚举的对象, 而以前它们需要一个具有连续数字键的标准对象. 如果枚举器每次迭代返回一个以上的值, 只使用第一个值. 例如, <code>Array(mymap*)</code> 创建一个包含 <em>mymap</em> 键的数组.</p>
<p>可变函数调用以前对命名参数的支持不完整. 这已经被禁用, 以消除正确实现命名参数的可能障碍.</p>
<p>用户定义的函数可以使用新的关键字 <code>unset</code> 作为参数的默认值, 以使参数在没有提供值的情况下被 "unset". 然后函数可以使用 IsSet() 来确定是否提供了一个值. <code>unset</code> 目前不允许在任何其他情况下使用.</p>
<p>当函数调用出现而没有定义时, 脚本不再从函数库(Lib) 文件夹中自动包含, 这是因为复杂性和潜在的事故增加(现在, <code>MyFunc()</code> 中的 <code>MyFunc</code> 可以是任何变量). <code>#Include &lt;LibName&gt;</code> 和以前一样工作. 在未来的版本中, 它可能会被模块支持所取代.</p>
<p>可变内置函数现在的 <code>MaxParams</code> 值等于 <code>MinParams</code>, 而不是一个任意的数字(如 255 或 10000). 使用 <code>IsVariadic</code> 来检测, 没有上限.</p>
<h4 id="byref">ByRef</h4>
<p><a href="Functions.htm#ByRef">ByRef 参数</a>现在使用 <code>&amp;param</code>, 而不是 <code>ByRef 参数</code> 来声明, 在用法上有一些区别.</p>
<p>ByRef 参数不再隐式地接受对调用者的变量的引用. 相反, 调用者必须用<a href="Variables.htm#ref">引用运算符</a>(<code>&amp;var</code>) 显式地传递一个引用. 这允许更多的灵活性, 例如在其他地方存储引用, 用可变函数接受引用, 用可变调用传递引用.</p>
<p>当一个参数被标记为 ByRef 时, 任何试图显式传递非 VarRef 值的行为都会导致抛出错误. 否则, 函数可以用 <code>param is VarRef</code> 检查引用, 用 <code>IsSetRef(param)</code> 检查目标变量是否有一个值, 并用 <code>%param%</code> 显式解除引用.</p>
<p>在递归调用时, ByRef 参数现在能够从同一函数的前一个实例中接收对局部变量的引用.</p>
<h3 id="nested-functions">套嵌函数</h3>
<p>一个函数可以被定义在另一个函数里面. 一个嵌套的函数可以自动从包围的函数中 "捕获" 非静态局部变量(在适当的条件下), 允许它们在包围的函数返回后使用.</p>
<p>新的 "胖箭头" <code>=&gt;</code> 运算符也可以用来创建嵌套函数.</p>
<p>有关详情, 请参阅<a href="Functions.htm#nested">套嵌函数</a>.</p>
<h3 id="uncategorized">未分类</h3>
<p>当初始化一个已声明的变量或可选参数时, 必须用 <code>:=</code> 来代替 <code>=</code>.</p>
<p><code>return %var%</code> 现在做了一个双重引用; 以前它等同于 <code>return var</code>.</p>
<p><a href="commands/_Include.htm">#Include</a> 默认是相对于包含当前文件的目录而言的. 其参数现在可以选择用引号括起来.</p>
<p><a href="commands/_ErrorStdOut.htm">#ErrorStdOut</a> 的参数现在可以选择用引号括起来.</p>
<p>现在要求标签名称只能由字母, 数字, 下划线和非 ASCII 字符组成(与变量, 函数等相同).</p>
<p>函数中定义的标签具有局部空间(作用域); 它们只在该函数中可见, 并且不会与其他地方定义的标签冲突. 局部标签不可能被外部调用(即使通过内置函数). 可以使用嵌套函数来代替, 允许充分使用局部变量.</p>
<p><code>for k, v in obj</code>:</p>
<ul>
<li>对象的调用方式已经改变. 请参阅 <em>枚举器</em>.</li>
<li>在循环中断或完成后, <code>for</code> 将 k 和 v 恢复到循环开始前的值.</li>
<li>如果 <em>obj</em> 不是对象, 或者在检索或调用其枚举器时出现问题, 则抛出异常.</li>
<li>最多可以使用 19 个变量.</li>
<li>变量可以被省略.</li>
</ul>
<p>转义逗号不再有任何意义. 以前, 如果在命令参数中没有括号的表达式中使用, 就会强制逗号被解释为多语句运算符, 而不是作为参数之间的分隔符. 它只对命令起作用, 不能用于函数或变量声明.</p>
<p>转义序列 <code>`s</code> 现在可以在支持 <code>`t</code> 的地方使用. 以前只允许 #IfWin 和 (Join.</p>
<p><code>*/</code> 现在可以放在行尾, 以结束多行注释, 以解决 <code>/* */</code> 在其他语言中工作方式有关的一个常见的混淆点. 由于存在歧义的风险(例如以 <code>*/</code> 结尾的热字符串), 任何没有以 <code>*/</code> 结尾的 <code>/*</code> 不再被忽略(颠覆了(逆转) AHK_L 修订版 54 中的更改).</p>
<p>在支持的范围(64 位有符号整数) 之外的整数常量和数字字符串现在会溢出/环绕, 而不是被限制在最小/最大值上. 这与数学运算符一致, 因此 <code>9223372036854775807+1 == 9223372036854775808</code>(但两者都生成 -9223372036854775808). 这有利于对 64 位数值进行位操作.</p>
<p>对于数字字符串来说, 除了空格和制表符之外, 允许在数字前面添加空白字符的情况比较少. 一般的规则(在 v1 和 v2 中) 是只允许使用空格和制表符, 但在某些情况下, 由于 C 语言运行库的惯例, 允许使用其他空白字符.</p>
<p><code>Else</code> 现在可以与 <code>Loop</code>, <code>For</code>, <code>While</code> 和 <code>Catch</code> 一起使用. 对于循环, 如果循环的迭代次数为零, 它将被执行. 对于 <code>Catch</code>, 如果在 <code>Try</code> 中没有抛出异常它将被执行(如果抛出任何错误或值, 即使没有与值的类别相匹配的 <code>Catch</code> 也不会被执行). 因此, 在不使用大括号的情况下 <code>Else</code> 的解释可能与以前的版本不同. 例如:</p>
<pre>if condition
{
    while condition
        <em>; 每个迭代都会执行的语句</em>
} <em>; 这些大括号现在是必须的, 否则 else 会与 while 相关联</em>
else
    <em>; if condition 为 false 时, 执行的语句</em>
</pre>
<h3 id="continuation-sections">延续片段</h3>
<p>智能 LTrim: 默认行为是计算延续片段选项下面第一行的前导空格或制表符的数量, 并从此后的每一行中删除该数量的空格或制表符. 如果第一行中混合了空格和制表符, 只有第一种类型的字符被视为缩进. 如果任何一行的缩进幅度小于第一行, 或者使用了错误的字符, 则该行的所有前导空白将被原封不动地保留.</p>
<p>如果延续片段以引号字符串开始, 引号会被自动转义(即它们被解释为原义字符). 这就避免需要在多行字符串中转义引号(如果开始和结束的引号都在延续片段之外), 同时仍然允许多行表达式包含带引号字符串.</p>
<p>如果延续片段上方的行以一个名称字符结束, 并且该部分不以引号字符串开始, 则会自动插入一个空格, 以分隔名称和延续片段的内容. 这允许在 <code>return</code>, 函数调用语句等之后的多行表达式中使用一个延续片段. 它还可以确保变量名称不与其他标记(或名称) 连接, 造成无效的表达.</p>
<p>表达式中的换行字符(<code>`n</code>) 被当作空格处理. 这使得多行表达式可以使用默认选项(即省略 <code>Join</code>) 的延续片段来编写.</p>
<p>由于不再需要转义这些字符, 所以删除 <code>,</code> 和 <code>%</code> 选项.</p>
<p>如果 <code>(</code> 或 <code>)</code> 出现在延续片段潜在的选项中(除了作为 <code>Join</code> 选项的一部分), 整个行不会被解释为延续片段的开始. 换句话说, 像 <code>(x.y)()</code> 和 <code>(x=y) &amp;&amp; z()</code> 这样的行会被解释为表达式. 多行表达式也可以在行首以开括号开始, 前提是在第一个物理行中至少有一个其他的 <code>(</code> 或 <code>)</code>. 例如, 整个表达式可以用 <code>((</code> ... <code>))</code> 括起来.</p>
<p>不包括上述情况, 如果存在任何无效的选项, 会显示加载时错误, 而不是忽略无效的选项.</p>
<p>以 <code>(</code> 开头的行和以 <code>:</code> 结尾的行不再因为看起来像一个标签而被排除为延续片段的开头, 因为 <code>(</code> 在标签名称中不再有效. 这使得像 <code>(Join:</code> 这样的代码有可能是一个延续片段的开始. 然而, <code>(:</code> 是一个错误, 而 <code>(::</code> 仍然是一个热键.</p>
<p>在表达式和函数/属性定义中支持一种新的延续行方法, 它利用了每个 <code>(</code>/<code>[</code>/<code>{</code> 必须与相应的 <code>)</code>/<code>]</code>/<code>}</code> 相匹配这一事实. 换句话说, 如果一行包含一个未封闭的 <code>(</code>/<code>[</code>/<code>{</code> 它将与后续的行连接, 直到开头和结尾符号的数量平衡. 如果没有其他未封闭的符号, 并且括号前面没有紧接着的运算符, 那么行末的括号 <code>{</code> 被认为是一个真正的括号(而不是一个对象原义语法的开始).</p>
<h3 id="continuation-lines">延续行</h3>
<p>现在, 对于将符号视为表达式运算符的上下文, 行延续更具选择性. 一般来说, 逗号和表达式运算符不能再用于文本上下文中的延续, 例如与热字符串或指令(除 #HotIf 外) 一起, 或在未封闭的引号字符串之后.</p>
<p>行延续现在对行末的表达式运算符有效.</p>
<p><code>is</code>, <code>in</code> 和 <code>contains</code> 可以用于行延续, 尽管 <code>in</code> 和 <code>contains</code> 仍然被保留/尚未作为运算符实现.</p>
<p><code>and</code>, <code>or</code>, <code>is</code>, <code>in</code> 和 <code>contains</code> 可以作为行延续运算符, 即使后面是赋值或其他二进制运算符, 因为这些不再是有效的变量名. 相比之下, v1 版对 <code>and</code>/<code>or</code> 后跟以下任一项都有例外: <code>&lt;&gt;=/|^:,</code></p>
<p>当 <code>.</code> 被用于延续时, 如果在一行开始时 <code>.</code> 右边没有空格或制表符, 那么这两行就不再自动用空格分隔, 如 <code>.VeryLongNestedClassName</code>. 请注意 <code>x .123</code> 总是属性访问(而不是自动串联), 而 <code>x+.123</code> 在有或没有空格的情况下都可以工作.</p>
<h3 id="types">类型</h3>
<p>一般来说, v2 对任何依赖值的类型的代码产生更一致的结果.</p>
<p>在 v1 中, 一个变量可以同时包含一个字符串和一个缓存的二进制数字, 每当变量被用作数字时, 这个数字就会被更新. 由于这个缓存的二进制数是检测数值类型的唯一方法, 由表达式(如 <code>var+1</code> 或 <code>abs(var)</code>) 进行的内部缓存的副作用有效地改变了 <code>var</code> 的 "类型". v2 禁用了这种缓存, 因此 <code>str := "123"</code> 总是一个字符串 <code>int := 123</code> 总是一个整数. 因此, <code>str</code> 每次被用作数字时都需要进行转换(而不是只在第一次), 除非它最初被赋值为纯数字.</p>
<p>内置的 "变量" <code>true</code>, <code>false</code>, <code>A_PtrSize</code>, <code>A_IsUnicode</code>, <code>A_Index</code> 和 <code>A_EventInfo</code> 总是返回纯整数, 而不是字符串. 在 v1 中, 由于某些优化, 它们有时会返回字符串, 而这些优化在 v2 中已经被取代了.</p>
<p>所有的原义数字在加载时都被转换为纯二进制数字, 而它们的字符串表示形式则被丢弃. 例如, <code>MsgBox 0x1</code> 等同于 <code>MsgBox 1</code>, 而 <code>MsgBox 1.0000</code> 等同于 <code>MsgBox 1.0</code>(因为浮点数的格式已经改变). 在变量中存储数字或从用户自定义函数中返回数字都会保留其纯数字状态.</p>
<p>现在浮点数的默认格式指定为 <code>.17g</code> (以前是 <code>0.6f</code>), 这在很多情况下更紧凑, 更准确. 默认值不能更改, 但可以用 <code>Format</code> 来获得不同的格式.</p>
<p>带引号的字符串和通过连接带引号的字符串产生的字符串不再无条件地被视为非数字. 相反, 它们被视为与存储在变量中或从函数中返回的字符串相同. 这有以下影响:</p>
<ul>
<li>带引号的文字 <code>"0"</code> 被认为是 false.</li>
<li><code>("0xA") + 1</code> 和 <code>("0x" Chr(65)) + 1</code> 产生 11 而不是失败.</li>
<li><code>x[y:="0"]</code> 和 <code>x["0"]</code> 现在的行为是一样的.</li>
</ul>
<p>如果运算数都是字符串, 运算符 <code>=</code> 和 <code>!=</code> 现在按字母顺序比较它们的运算数, 即使它们是数字字符串. 当两个运算数都是数字且至少有一个运算数是纯数字(不是字符串) 时, 仍然进行数字比较. 例如, 54 和 "530" 是数字比较, 而 "54" 和 "530" 是字母比较. 此外, 存储在变量中的字符串与原义字符串的处理没有区别.</p>
<p>关系运算符 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> 和 <code>&gt;=</code> 如果与非数字字符串一起使用, 现在会出现异常. 以前, 它们根据两个输入是否为数字, 按字母顺序进行比较, 但带引号的字符串总是被认为是非数字的. 使用 <code>StrCompare(a, b, CaseSense)</code> 代替.</p>
<p><code>Type(Value)</code> 返回下列字符串之一: 字符串, 整数, 浮点数, 或者一个对象的具体类.</p>
<p><code>Float(v)</code>, <code>Integer(v)</code> 和 <code>String(v)</code> 将 <code>v</code> 转换成相应的类型, 如果不能进行转换, 则抛出异常(例如 <code>Integer("1z")</code>). <code>Number(v)</code> 转换为整数或浮点数. 如果 <code>v</code> 时一个对象, <code>String</code> 调用 <code>v.ToString()</code>. (在理想情况下, 这适用于任何从对象到字符串的隐式转换, 但目前的实现使其变得困难.)</p>
<h2 id="objects">对象</h2>
<p>对象现在使用更结构化的类-原型方法, 将类/静态成员与实例成员分开. 许多内置方法和 Obj函数已经被移动, 重命名, 更改或删除.</p>
<ul>
<li>每个用户定义的或内置的类都是一个类对象(<a href="objects/Class.htm">Class</a> 的实例) 只公开使用 <code>static</code> 关键字定义的方法和属性(包括从基类继承的静态成员) 和嵌套类.</li>
<li>每个类对象都有一个 <a href="objects/Class.htm#Prototype">Prototype</a> 属性, 成为该类所有实例的 <code>base</code>. 类体内的所有非静态方法和属性定义都附着在原型对象上.</li>
<li>实例化是通过调用静态方法 <a href="objects/Class.htm#Call">Call</a> 来执行的, 如 <code>myClass.Call()</code> 或 <code>myClass()</code>. 这允许类完全覆盖构造行为(例如, 实现类工厂或单件, 或者构造一个原生数组或 Map 而不是一个对象), 尽管初始化通常仍应在 <code>__New</code> 中执行. 现在 <code>__New</code> 的返回值被忽略; 要覆盖返回值, 请在 Call 方法中这样做.</li>
</ul>
<p>混合的对象类型已经被拆分成 <code>Object</code>, <code>Array</code> 和 <code>Map</code>(关联数组).</p>
<p>Object 现在是所有用户定义 <strong>和内置</strong> 对象的根类(这不包括 VarRef 和 COM 对象). 添加到 <code>Object.Prototype</code> 的成员被所有 AutoHotkey 对象继承.</p>
<p>运算符 <code>is</code> 的期望是一个类, 所以 <code>x is y</code> 在基对象链中检查 <code>y.Prototype</code>. 要检查 <code>y</code> 本身, 请调用 <code>x.HasBase(y)</code> 或 <code>HasBase(x, y)</code>.</p>
<p>用户定义的类也可以显式地继承 <code>Object</code>, <code>Array</code>, <code>Map</code> 或其他一些内置类(尽管这样做并不总是有用), 如果没有指定, 那么 <code>Object</code> 就是默认的基类.</p>
<p><code>new</code> 运算符已被删除. 取而代之的是省略该运算符, 如 <code>MyClass()</code>. 要 <em>基于</em> 一个不是类的对象的构造一个对象, 请使用 <code>{}</code> 或 <code>Object()</code>(或通过任何其它方法) 创建该对象, 并设置它的 <code>base</code>. <code>__Init</code> 和 <code>__New</code> 可以被显式调用, 但一般来说, 这仅适用于实例化类.</p>
<p>嵌套类的定义现在产生一个带有 <em>get</em> 和 <em>call</em> 访问函数的动态属性, 而不是一个简单的值属性. 这是为了支持以下行为:</p>
<ul>
<li><code>Nested.Class()</code> 不会将 <code>Nested</code> 传递给 <code>Nested.Class.Call</code> 并最终传递给 <code>__New</code>, 否则会发生这种情况, 因为这是作为方法调用的函数对象的正常行为(这是这里使用嵌套类的方式).</li>
<li><code>Nested.Class := 1</code> 默认是一个错误(该属性是只读的).</li>
<li>第一次引用或调用该类会使其初始化.</li>
</ul>
<p>GetCapacity 和 SetCapacity 被删除.</p>
<ul>
<li><a href="objects/Object.htm#GetCapacity">ObjGetCapacity</a> 和 <a href="objects/Object.htm#SetCapacity">ObjSetCapacity</a> 现在只影响对象包含属性的容量, 而且预计不会被经常使用. 不支持设置属性, 数组元素或 Map 元素的字符串缓冲的容量; 对于二进制数据, 使用<a href="objects/Buffer.htm">缓冲</a>对象.</li>
<li>Array 和 Map 具有 Capacity 属性, 对应于对象的当前数组或 Map 分配的容量属性.</li>
</ul>
<p>其他多余的 Obj函数(对应于 Object 的内置方法) 被删除. <a href="objects/Object.htm#HasOwnProp">ObjHasOwnProp</a>(以前的 ObjHasKey) 和 <a href="objects/Object.htm#OwnProps">ObjOwnProps</a>(以前的 ObjNewEnum) 被保留下来, 以便于安全检查重新定义了这些方法的对象(以及没有定义这些方法的原始原型). ObjCount 被 <a href="objects/Object.htm#OwnPropCount">ObjOwnPropCount</a> 取代(仅是一个函数, 适用于所有对象), Map 具有自己的 <a href="objects/Map.htm#Count">Count</a> 属性.</p>
<p>ObjRawGet 和 ObjRawSet 合并为 <a href="objects/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a> 和 <a href="objects/Object.htm#DefineProp">DefineProp</a>. 添加它们的最初原因被其他变化所取代, 例如 <code>Map</code> 类型, 元函数工作方式的变化以及 DefineProp 本身在某些方面取代了元函数.</p>
<p>顶级类的定义现在创建了一个常量(只读变量); 也就是说, 现在对类名的赋值是一个错误, 而不是一个可选的警告, 除非是局部变量遮蔽了全局类(现在在函数内部赋值时默认发生).</p>
<h3 id="primitive-values">原始值</h3>
<p>原始值通过将方法和属性调用委托给基于其类型的原型对象来模拟对象, 而不是 V1 的 "默认基对象". Integer 和 Float 继承于 Number. String 和 Number 继承于 Primitive. Primitive 和 Object 继承于 Any. 这些都作为预定义的类存在.</p>
<h3 id="properties-and-methods">属性和方法</h3>
<p>与 v2.0-a104 到 v2.0-a127 不同, 方法是由属性定义的, 方法与属性是分开的. 然而, 与 v1 不同的是, 由类方法定义(或内置方法) 创建的属性默认为只读. 方法仍然可以通过分配新的值属性来创建, 这通常与 v1 中的作用相同.</p>
<p>Object 类定义了处理属性和方法的新方法: <a href="objects/Object.htm#DefineProp">DefineProp</a>, <a href="objects/Object.htm#DeleteProp">DeleteProp</a>, <a href="objects/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a>, <a href="objects/Object.htm#HasOwnProp">HasOwnProp</a>, <a href="objects/Object.htm#OwnProps">OwnProps</a>. 为所有的值定义了额外的方法(除了 ComObjects): <a href="objects/Any.htm#GetMethod">GetMethod</a>, <a href="objects/Any.htm#HasProp">HasProp</a>, <a href="objects/Any.htm#HasMethod">HasMethod</a>.</p>
<p>Object, Array 和 Map 现在是独立的类型, 数组元素与属性是分开的.</p>
<p>所有内置方法和属性(包括 <code>base</code>) 的定义方式与用户定义的相同. 这确保了行为的一致性, 并允许检测, 检索或重新定义内置和用户定义的成员.</p>
<p>如果属性不接受参数, 它们会自动传递给由该属性返回的对象(或者抛出).</p>
<p>试图检索一个不存在的属性对于所有类型的值或对象来说都被视为一个错误, 除非 <code>__get</code> 被定义. 然而, 在大多数情况下, 设置一个不存在的属性将创建它.</p>
<p>多维数组技巧被删除. <code>x.y[z]:=1</code> 不再在 <code>x.y</code> 中创建一个对象, 并且 <code>x[y,z]</code> 是一个错误, 除非 x.__item 处理两个参数(或者 x.__item.__item 处理, 等等.).</p>
<p>如果一个属性定义了 <code>get</code> 但没有 <code>set</code>, 赋值会抛出而不是覆盖该属性.</p>
<p><a href="objects/Object.htm#DefineProp">DefineProp</a> 可以用来定义检索, 设置 <em>或调用</em> 特定的属性时会发生什么, 而不需要定义任何元函数. 类中的属性和方法定义使用相同的机制, 因此可以用相同的名称定义属性 getter/setter(获取器/设置器) 和方法.</p>
<p><code>{}</code> 对象原义语法现在直接设置 <em>自有属性</em> 的值或对象的 <code>base</code>. 也就是说, <code>__Set</code> 和属性设置器不再被调用(通常只有在参数列表中设置了 <code>base</code> 时才有可能).</p>
<h3 id="staticclass-variables">Static/Class 变量</h3>
<p>Static/class 初始化器现在在 <code>static __Init</code> 方法的上下文中执行, 所以 <code>this</code> 指的是类, 初始化器可以创建局部变量. 它们在类第一次被引用时被计算(而不是在自动执行部分开始前被计算, 严格按照定义的顺序). 如果类没有被更早地引用, 它们会在执行过程中到达类定义时被计算, 所以全局变量的初始化可以先发生, 而不用把它们放到类中.</p>
<h3 id="meta-functions">元函数</h3>
<p>元函数被大大简化了; 它们的行为就像普通方法一样:</p>
<ul>
<li>它们在层次结构中被定义的位置并不重要.</li>
<li>如果被覆盖, 基本版本不会被自动调用. 如果需要, 脚本可以调用 <code>super.__xxx()</code>.</li>
<li>如果定义了, 它必须执行默认的动作; 例如, 如果 __set 不存储值, 它就不被存储.</li>
<li>行为不依赖于方法是否使用 <code>return</code> (但当然, __get 和 __call 仍然需要返回一个值).</li>
</ul>
<p>方法和属性参数是以数组形式传递的. 这对链式基类/超类的调用进行了优化, 并且(与 MaxParams 验证相结合) 鼓励作者处理 args. 对于__set, 被分配的值被单独传递.</p>
<pre><code><div>this.__call(name, args)
this.__get(name, args)
this.__set(name, args, value)
</div></code></pre>
<p>定义的属性和方法优先于元函数, 不管它们是否被定义在基对象中.</p>
<p>__Call 不会在内部调用 __Enum(以前的 _NewEnum) 或 Call 时被调用, 例如当一个对象被传递到 for-loop 或一个函数对象被 SetTimer 调用时.</p>
<p>当每个类被初始化时, 静态方法 __New 被调用, 如果由该类定义或从超类继承. 有关详情, 请参阅 <a href="#staticclass-variables">Static/Class 变量</a>(上面的) 和 <a href="Objects.htm#static__New">Class 初始化</a>.</p>
<h3 id="array">Array</h3>
<p><code>class Array extends Object</code></p>
<p>数组对象包含值的列表或序列, 第一个元素的索引为 1.</p>
<p>当分配或检索一个数组元素时, 索引的绝对值必须在 1 和数组的 <a href="objects/Array.htm#Length">Length</a> 之间, 否则会产生一个异常. 一个数组可以通过适当的方法插入或删除元素, 或者通过分配 <a href="objects/Array.htm#Length">Length</a> 来调整大小.</p>
<p>目前在访问元素时需要使用括号, 即 <code>a.1</code> 指的是一个属性, 而 <code>a[1]</code> 指的是一个元素.</p>
<p>负值可以用来做反向索引.</p>
<p><a href="objects/Array.htm#Clone">Clone</a>, <a href="objects/Array.htm#Delete">Delete</a>, <a href="objects/Array.htm#InsertAt">InsertAt</a>, <a href="objects/Array.htm#Pop">Pop</a>, <a href="objects/Array.htm#Push">Push</a> 和 <a href="objects/Array.htm#RemoveAt">RemoveAt</a> 的用法基本没有变化. HasKey 被重命名为 <a href="objects/Array.htm#Has">Has</a>. <a href="objects/Array.htm#Length">Length</a> 现在是一个属性. 增加 <a href="objects/Array.htm#Capacity">Capacity</a> 属性.</p>
<p>数组可以用 <code>Array(values*)</code> 或 <code>[values*]</code> 构建. 可变函数接收一个数组的参数, 数组也由几个内置函数创建.</p>
<p>For-loop 的用法是 <code>for val in arr</code> 或 <code>for idx, val in arr</code>, 其中 <code>idx = A_Index</code> 是默认的. 也就是说, 缺乏值的元素仍然被枚举, 如果只传递一个变量, 则不返回索引.</p>
<h3 id="map">Map</h3>
<p>Map 对象是一个关联数组, 其功能类似于 v1 的对象, 但没有那么多歧义.</p>
<ul>
<li><a href="objects/Map.htm#Clone">Clone</a> 的使用方法和以前一样.</li>
<li><a href="objects/Map.htm#Delete">Delete</a> 一次只能删除一个键.</li>
<li>HasKey 被改名为 <a href="objects/Map.htm#Has">Has</a>.</li>
<li><a href="objects/Map.htm#Count">Count</a> 现在是一个属性.</li>
<li>新属性: <a href="objects/Map.htm#Capacity">Capacity</a>, <a href="objects/Map.htm#CaseSense">CaseSense</a></li>
<li>新方法: <a href="objects/Map.htm#Get">Get</a>, <a href="objects/Map.htm#Set">Set</a>, <a href="objects/Map.htm#Clear">Clear</a></li>
<li>字符串键默认是区分大小写的, 并且不会被转换为整数.</li>
</ul>
<p>目前 Float 键仍然被转换为字符串.</p>
<p>在访问元素时, 需要使用括号; 例如 <code>a.b</code> 指的是一个属性, 而 <code>a["b"]</code> 指的是一个元素. 与 v1 不同, 一个属性或方法不能通过分配一个数组元素而被意外地禁用.</p>
<p>如果试图检索一个不存在的元素的值, 就会抛出异常, 除非地图定义了一个 <a href="objects/Map.htm#Default">Default</a> 属性. <code>MapObj.Get(key, default)</code> 可以用来为每个请求显式地提供一个默认值.</p>
<p>使用 <code>Map(Key, Value, ...)</code> 从一个键值对列表中创建一个 Map.</p>
<h3 id="enumeration">枚举器</h3>
<p>枚举器模型的变更:</p>
<ul>
<li>__Enum(n) 替换了 _NewEnum().</li>
<li>所需的参数 n 包含 for-loop 中的变量数量, 以允许它影响枚举, 而不必将初始化推迟到第一个迭代调用.</li>
<li>Call() 替换了 Next(), 除了 ByRef 的工作方式不同外, 用法相同; 例如, 定义为 <code>Call(&amp;a)</code> 的方法应该分配 <code>a := next_value</code> 而 <code>Call(a)</code> 将接收一个 <code>VarRef</code>, 所以应该分配 <code>%a% := next_value</code>.</li>
<li>如果 __Enum 不存在, 则假定该对象是一个枚举器. 这允许直接使用函数对象(如闭包).</li>
</ul>
<p>由于数组元素和属性现在是分开的, 所以枚举属性需要通过调用 <a href="objects/Object.htm#OwnProps">OwnProps</a> 显式地创建一个枚举器.</p>
<h3 id="bound-functions">绑定函数</h3>
<p>当绑定函数被调用时, 由调用者传递的参数将填补在创建绑定函数时被省略的位置. 例如, <code>F.Bind(,b).Call(a,c)</code> 调用 <code>F(a,b,c)</code>, 而不是 <code>F(,b,a,c)</code>.</p>
<h3 id="com-objects-comobject">COM 对象(ComObject)</h3>
<p>COM 封装对象现在可以识别为几个不同类的实例, 这取决于它们的变体类型(和以前一样, 这影响它们支持哪些方法和属性) :</p>
<ul>
<li><code>ComValue</code> 是所有 COM 包装器对象的基类.</li>
<li><code>ComObject</code> 是 VT_DISPATCH 的非空指针; 也就是说, 通常是一个有效的 COM 对象, 可以由脚本使用正常的对象语法来调用.</li>
<li><code>ComObjArray</code> 用于 VT_ARRAY(SafeArrays).</li>
<li><code>ComValueRef</code> 用于 VT_BYREF.</li>
</ul>
<p>这些类可以用 <code>obj is ComObject</code> 和类似的手段来进行类型检查. 通过修改各自的原型对象, 可以为 ComValue, ComObjArray 和 ComValueRef(但不是 ComObject) 类型的对象定义属性和方法.</p>
<p><code>ComObject(CLSID)</code> 创建 ComObject; 也就是说, 这是新的 ComObjCreate.</p>
<p>注意: 如果你正在更新旧的代码, 并且由于向 ComObject 传递一个整数而得到一个 TypeError, 你很可能应该调用 ComValue 来代替.</p>
<p><code>ComValue(vt, value)</code> 创建一个封装对象. 它可以返回上面列出的任何类的实例. 这取代了 <code>ComObjParameter(vt, value)</code>, <code>ComObject(vt, value)</code> 以及作为参数与 <em>变体类型</em> 和 <em>value</em> 一起使用的任何其他名称. <em>value</em> 被转换为适当的类型(按照 COM 惯例), 而不是要求一个具有正确二进制值的整数. 特别是, 当传递一个整数时, 以下的行为与以前不同. R4, R8, Cy, Date. 指针类型像以前一样允许一个纯整数地址, 或者一个对象/ComValue.</p>
<p><code>ComObjFromPtr(pdsp)</code> 是一个类似于 <code>ComObjEnwrap(dsp)</code> 的函数, 但与 ObjFromPtr 一样, 它不调用指针上的 AddRef. 在 v1 中的等价物是 <code>ComObject(9, dsp, 1)</code>; 在 v1 中省略第三个参数会引起 AddRef.</p>
<p>对于 ComValue 和 ComObjFromPtr, 请注意 AddRef 永远不会被自动调用; 在这方面, 它们的行为与 v1 中的 <code>ComObject(9, value, 1)</code> 或 <code>ComObject(13, value, 1)</code> 类似. 这并不一定意味着你在更新旧的脚本时应该添加 <code>ObjAddRef(value)</code> 因为许多脚本错误地使用了旧函数.</p>
<p>具有变体类型 VT_BYREF, VT_ARRAY 或 VT_UNKNOWN 的 COM 封装对象现在有一个 <code>Ptr</code> 属性, 相当于 <code>ComObjValue(ComObj)</code>. 这允许它们以 <code>Ptr</code> 参数类型被传递给 DllCall 或 ComCall. 它还允许将对象直接传递给 NumPut 或 NumGet, 这可以与 VT_BYREF(访问调用者的类型变量), VT_ARRAY(访问 SAFEARRAY 字段) 或 VT_UNKNOWN(检索 vtable 指针) 一起使用.</p>
<p>具有变体类型 VT_DISPATCH 或 VT_UNKNOWN 和空接口指针的 COM 封装对象现在有一个 <code>Ptr</code> 属性, 可以被读取或分配. 一旦分配了一个非空的指针, 该属性就是只读的. 这是为了与 DllCall 和 ComCall 一起使用, 所以在函数返回后不需要手动包装指针.</p>
<p>ComObjArray 的枚举现在与 Array 一致; 例如 <code>for value in arr</code> 或 <code>for index, value in arr</code>, 而不是 <code>for value, vartype in arr</code>. <code>index</code> 索引的起始值是 ComObjArray(<code>arr.MinIndex()</code>) 的下限, 通常是 0.</p>
<p>整数类型 I1, I8, UI1, UI2, UI4 和 UI8 现在被转换为整数, 而不是字符串. 这些在 COM 调用中很少发生, 但这也适用于 VT_BYREF 包装器. VT_ERROR 不再被转换为整数, 而是产生一个 ComValue.</p>
<p>当属性或方法调用失败时, COM 对象不在设置 <a href="Variables.htm#LastError">A_LastError</a>.</p>
<h3 id="default-property">默认属性</h3>
<p>COM 对象可能有一个 "默认属性", 它有两种用途:</p>
<ul>
<li>对象的 <em>value</em>, 例如, 在 VBScript 中, <code>MsgBox obj</code> 通过调用其默认成员来计算该对象.</li>
<li>一个集合的索引属性, 通常被命名为 <code>Item</code> 或 <code>item</code>.</li>
</ul>
<p>AutoHotkey v1 没有默认属性的概念, 所以如果省略了属性名称, COM 对象包装器会调用默认属性; 即 <code>obj[]</code> 或 <code>obj[,x]</code>.</p>
<p>然而, AutoHotkey v2 将属性与数组/ Map /集合项分开, 为此 <code>obj[x]</code> 被映射到对象的默认属性(无论 <code>x</code> 是否存在). 对于 AutoHotkey 对象, 这就是 <code>__Item</code>.</p>
<p>一些代表数组或集合的 COM 对象不公开默认属性, 所以在 v2 中不能用 <code>[]</code> 来访问项目. 例如, JavaScript 数组对象和其他一些通常与 JavaScript 一起使用的对象将数组元素作为属性公开. 在这种情况下, <code>arr.%i%</code> 可以用来访问一个数组元素的属性.</p>
<p>当 AutoHotkey v2 的 <code>Array</code> 对象被传递给 JavaScript 时, 它的元素不能被 JavaScript 的 <code>arr[i]</code> 检索, 因为这将试图访问一个属性.</p>
<h3 id="com-calls">COM 调用</h3>
<p>通过 IDispatch 接口对 AutoHotkey 对象的调用现在透明地支持 <code>VT_BYREF</code> 参数. 这最常被用于 COM 事件(<a href="commands/ComObjConnect.htm">ComObjConnect</a>).</p>
<p>对于 <code>VT_BYREF</code> 参数, 一个未命名的临时 var 被创建, 其值从调用者的变量中复制, 并且一个 <code>VarRef</code> 被传递给 AutoHotkey 函数/方法. 返回时, 值从临时变量中复制到调用者的变量中.</p>
<p>一个函数/方法可以通过声明参数 ByRef(用 <code>&amp;</code>) 或显式解引来赋值.</p>
<p>例如, <code>VT_BYREF|VT_BOOL</code> 类型的参数以前会收到一个 ComObjRef 对象, 并且会被赋值, 如 <code>pbCancel[] := true</code> 或 <code>NumPut(-1, ComObjValue(pbCancel), "short")</code>. 现在, 这个参数可以被定义为 <code>&amp;bCancel</code> 并像 <code>bCancel := true</code> 那样赋值; 或者可以被定义为 <code>pbCancel</code> 并像 <code>%pbCancel% := true</code> 那样赋值.</p>
<h2 id="library">库</h2>
<p>删除的:</p>
<ul>
<li>Asc() (使用 <a href="commands/Ord.htm">Ord</a>)</li>
<li>AutoTrim (使用 <a href="commands/Trim.htm">Trim</a>)</li>
<li>ComObjMissing() (改为连续写两个逗号)</li>
<li>ComObjUnwrap() (如果需要, 使用 <a href="commands/ComObjValue.htm">ComObjValue</a> 和 <a href="commands/ObjAddRef.htm">ObjAddRef</a>)</li>
<li>ComObjEnwrap() (如果需要, 使用 <a href="commands/ComObjFromPtr.htm">ComObjFromPtr</a> 和 <a href="commands/ObjAddRef.htm">ObjAddRef</a> 代替)</li>
<li>ComObjError()</li>
<li>ComObjXXX() 其中 XXX 是显式定义的 ComObj 函数以外的任何东西(使用 <a href="commands/ComObjActive.htm">ComObjActive</a>, <a href="commands/ComValue.htm">ComValue</a> 或 <a href="commands/ComObjFromPtr.htm">ComObjFromPtr</a> 代替).</li>
<li>ControlSendRaw (使用 <code>ControlSend "{Raw}"</code> 或 <a href="commands/ControlSend.htm">ControlSendText</a> 代替)</li>
<li>EnvDiv</li>
<li>EnvMult</li>
<li>EnvUpdate (它的用处非常有限, 可以用一个简单的 <a href="commands/SendMessage.htm">SendMessage</a> 代替)</li>
<li>Exception (使用 <a href="objects/Error.htm">Error</a> 或一个适当的子类)</li>
<li>FileReadLine (使用<a href="commands/LoopFiles.htm">文件读取循环</a>或 <a href="commands/FileOpen.htm">FileOpen</a>)</li>
<li>Func (使用像 <code>MyFunc</code> 这样的直接引用)</li>
<li>Gosub</li>
<li>Gui, GuiControl, GuiControlGet (请参阅 <a href="#gui">Gui</a>)</li>
<li>IfEqual</li>
<li>IfExist</li>
<li>IfGreater</li>
<li>IfGreaterOrEqual</li>
<li>IfInString</li>
<li>IfLess</li>
<li>IfLessOrEqual</li>
<li>IfMsgBox (<a href="commands/MsgBox.htm">MsgBox</a> 现在返回按钮名称)</li>
<li>IfNotEqual</li>
<li>IfNotExist</li>
<li>IfNotInString</li>
<li>IfWinActive</li>
<li>IfWinExist</li>
<li>IfWinNotActive</li>
<li>IfWinNotExist</li>
<li>If between/is/in/contains (但请参阅 <a href="#isXXX">isXXX</a>)</li>
<li>Input (使用 <a href="commands/InputHook.htm">InputHook</a>)</li>
<li>IsFunc</li>
<li>Menu (使用 <a href="objects/Menu.htm">Menu/MenuBar 类</a>, <a href="commands/TraySetIcon.htm">TraySetIcon</a>, <a href="Variables.htm#IconTip">A_IconTip</a>, <a href="Variables.htm#IconHidden">A_IconHidden</a> 和 <a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a>)</li>
<li>MenuGetHandle (使用 <a href="objects/Menu.htm#Handle">Menu.Handle</a>)</li>
<li>MenuGetName (没有菜单名称; <a href="commands/MenuFromHandle.htm">MenuFromHandle</a> 是最接近的替代方法)</li>
<li>Progress (使用 <a href="objects/Gui.htm">Gui</a>)</li>
<li>SendRaw (使用 <code>Send "{Raw}"</code> 或 <a href="commands/Send.htm#SendText">SendText</a> 代替)</li>
<li>SetBatchLines (-1 现在是默认行为)</li>
<li>SetEnv</li>
<li>SetFormat (<a href="commands/Format.htm">Format</a> 可以用来格式化一个字符串)</li>
<li>SoundGet/SoundSet(请参阅 <a href="#Sound">Sound 函数</a>)</li>
<li>SoundGetWaveVolume/SoundSetWaveVolume (在平衡方面与 SoundGet/SoundSet 的行为略有不同, 但都没有保留平衡)</li>
<li>SplashImage (使用 <a href="objects/Gui.htm">Gui</a>)</li>
<li>SplashTextOn/Off (使用 <a href="objects/Gui.htm">Gui</a>)</li>
<li>StringCaseSense (使用各种参数)</li>
<li>StringGetPos (使用 <a href="commands/InStr.htm">InStr</a>)</li>
<li>StringLeft<br>
StringLen<br>
StringMid<br>
StringRight<br>
StringTrimLeft<br>
StringTrimRight  -- 使用 <a href="commands/SubStr.htm">SubStr</a> 来代替这些命令.</li>
<li>StringReplace (使用 <a href="commands/StrReplace.htm">StrReplace</a> 代替)</li>
<li>StringSplit (使用 <a href="commands/StrSplit.htm">StrSplit</a> 代替)</li>
<li>Transform</li>
<li>VarSetCapacity (对二进制数据/结构使用 <a href="objects/Buffer.htm">Buffer</a> 对象, 对 UTF-16 字符串使用 <a href="commands/VarSetStrCapacity.htm">VarSetStrCapacity</a>)</li>
<li>WinGetActiveStats</li>
<li>WinGetActiveTitle</li>
<li>#CommentFlag</li>
<li>#Delimiter</li>
<li>#DerefChar</li>
<li>#EscapeChar</li>
<li>#HotkeyInterval (使用 <a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a>)</li>
<li>#HotkeyModifierTimeout (使用 <a href="misc/A_HotkeyModifierTimeout.htm">A_HotkeyModifierTimeout</a>)</li>
<li>#IfWinActive, #IfWinExist, #IfWinNotActive, #IfWinNotExist (请参阅 <a href="commands/_HotIf.htm#optimization">#HotIf Optimization</a>)</li>
<li>#InstallKeybdHook (使用 <a href="commands/InstallKeybdHook.htm">InstallKeybdHook</a> 函数)</li>
<li>#InstallMouseHook (使用 <a href="commands/InstallMouseHook.htm">InstallMouseHook</a> 函数)</li>
<li>#KeyHistory (使用 <code>KeyHistory N</code>)</li>
<li>#LTrim</li>
<li>#MaxHotkeysPerInterval (使用 <a href="misc/A_MaxHotkeysPerInterval.htm">A_MaxHotkeysPerInterval</a>)</li>
<li>#MaxMem</li>
<li>#MenuMaskKey (使用 <a href="misc/A_MenuMaskKey.htm">A_MenuMaskKey</a>)</li>
<li>#NoEnv (现在是默认行为)</li>
</ul>
<p>重命名的:</p>
<ul>
<li>ComObjCreate() → <a href="commands/ComObject.htm">ComObject</a>, 它现在是一个类</li>
<li>ComObjParameter() → <a href="commands/ComValue.htm">ComValue</a>, 它现在是一个类</li>
<li>DriveSpaceFree → <a href="commands/DriveGetSpaceFree.htm">DriveGetSpaceFree</a></li>
<li>EnvAdd → <a href="commands/DateAdd.htm">DateAdd</a></li>
<li>EnvSub → <a href="commands/DateDiff.htm">DateDiff</a></li>
<li>FileCopyDir → <a href="commands/DirCopy.htm">DirCopy</a></li>
<li>FileCreateDir → <a href="commands/DirCreate.htm">DirCreate</a></li>
<li>FileMoveDir → <a href="commands/DirMove.htm">DirMove</a></li>
<li>FileRemoveDir → <a href="commands/DirDelete.htm">DirDelete</a></li>
<li>FileSelectFile → <a href="commands/FileSelect.htm">FileSelect</a></li>
<li>FileSelectFolder → <a href="commands/DirSelect.htm">DirSelect</a></li>
<li>#If → <a href="commands/_HotIf.htm">#HotIf</a></li>
<li>#IfTimeout → <a href="commands/_HotIfTimeout.htm">HotIfTimeout</a></li>
<li>StringLower → <a href="commands/StrLower.htm">StrLower</a> 和 <a href="commands/StrLower.htm">StrTitle</a></li>
<li>StringUpper → <a href="commands/StrLower.htm">StrUpper</a> 和 <a href="commands/StrLower.htm">StrTitle</a></li>
<li>UrlDownloadToFile → <a href="commands/Download.htm">Download</a></li>
<li>WinMenuSelectItem → <a href="commands/MenuSelect.htm">MenuSelect</a></li>
<li>LV, TV 和 SB 函数 → <a href="objects/GuiControl.htm">GuiControl</a> 的方法</li>
<li>File.__Handle → <a href="objects/File.htm#Handle">File.Handle</a></li>
</ul>
<h3 id="modified-commandsfunctions">修改的命令/函数</h3>
<p class="note">关于这一节的标题: v2 中没有命令, 只有函数. 标题引用两个版本.</p>
<p><code>Chr(0)</code> 返回一个长度为 1 的字符串, 包含一个二进制零. 这是改进了对字符串中二进制零的支持的结果.</p>
<p>如果等待期过了, <a href="commands/ClipWait.htm">ClipWait</a> 现在返回 0, 否则返回 1. ErrorLevel 被删除. 指定 0 不再等同于指定 0.5; 相反, 它产生尽可能短的等待.</p>
<p><code>ComObj()</code>: 这个函数有一种通配符的名字, 允许许多不同的后缀. 有些名字通常用于特定类型的参数, 如 <code>ComObjActive(CLSID)</code>, <code>ComObjParameter(vt, value)</code>, <code>ComObjEnwrap(dsp)</code>. 取而代之的是单独的函数/类, 不再有通配符名称. 有关详情, 请参阅 <a href="#com-objects-comobject">COM 对象(ComObject)</a>.</p>
<p>Control: 对 <a href="commands/Control.htm">Control 函数</a>, <a href="commands/SendMessage.htm">SendMessage</a> 和 <a href="commands/PostMessage.htm">PostMessage</a> 使用的 <a href="commands/Control.htm#Parameter"><em>Control</em> 参数</a>做了一些修改:</p>
<ul>
<li>它现在可以接受 HWND(必须是一个纯整数) 或具有 <code>Hwnd</code> 属性的对象, 如 <a href="objects/GuiControl.htm">GuiControl</a> 对象. HWND 可以识别一个控件或一个顶级窗口, 尽管后者通常只对少数几个函数才有意义(见下文).</li>
<li>它不再是可选的, 除了可以操作顶级窗口的函数(<a href="commands/ControlSend.htm">ControlSend[Text]</a>, <a href="commands/ControlClick.htm">ControlClick</a>, <a href="commands/SendMessage.htm">SendMessage</a>, <a href="commands/PostMessage.htm">PostMessage</a>) 或前面有其他可选的参数时(<a href="commands/ListViewGetContent.htm">ListViewGetContent</a>, <a href="commands/ControlGetPos.htm">ControlGetPos</a>, <a href="commands/ControlMove.htm">ControlMove</a>).</li>
<li>如果省略, 就会使用目标窗口来代替. 这与之前 <a href="commands/SendMessage.htm">SendMessage</a>/<a href="commands/PostMessage.htm">PostMessage</a> 的行为相匹配, 并取代了 <a href="commands/ControlSend.htm">ControlSend</a> 之前使用的 <code>ahk_parent</code> 特殊值.</li>
<li>空白的值是无效的. 函数从不默认目标窗口的最顶层的控件.</li>
</ul>
<p><a href="commands/ControlGetFocus.htm">ControlGetFocus</a> 现在返回控件的 HWND, 而不是其 ClassNN, 并且当它成功确定窗口没有焦点控件时, 不再认为有错误.</p>
<p><a href="commands/ControlMove.htm">ControlMove</a>, <a href="commands/ControlGetPos.htm">ControlGetPos</a> 和 <a href="commands/ControlClick.htm">ControlClick</a> 现在使用客户端坐标(像 <a href="objects/GuiControl.htm">GuiControl</a>) 而不是窗口坐标. 客户端坐标是相对于客户端区域的左上方而言的, 它不包括窗口的标题栏和边框. (控件只在客户端区域内渲染.)</p>
<p><a href="commands/ControlMove.htm">ControlMove</a>, <a href="commands/ControlSend.htm">ControlSend</a> 和 <a href="commands/ControlSetText.htm">ControlSetText</a> 现在使用与其他 Control 函数一致的参数顺序; 即 <em><strong>Control</strong>, WinTitle, WinText, ExcludeTitle, ExcludeText</em> 总是组合在一起(在参数列表的最后), 以帮助记忆.</p>
<p><a href="commands/CoordMode.htm">CoordMode</a> 不再接受 "Relative" 作为一种模式, 因为所有模式都是相对于某个东西的. 它与 "Window" 同义, 所以用它代替.</p>
<p><a href="commands/DllCall.htm">DllCall</a>: 请参阅下面的 <a href="#dllcall">DllCall</a> 部分.</p>
<p>如果没有被注册 "edit" shell 动词, <a href="commands/Edit.htm">Edit</a> 以前有针对 <code>.ini</code> 文件类型的后备行为. 由于脚本文件不需要有 <code>.ini</code> 扩展名. <code>AutoHotkey.ini</code> 是旧版本 AutoHotkey 中的默认脚本名称.</p>
<p>如果脚本是从 stdin 中读取的, 那么现在 <a href="commands/Edit.htm">Edit</a> 不会做任何事情, 而会尝试为 <code>*</code> 打开一个编辑器.</p>
<p>如果完全省略了 value 参数, <a href="commands/EnvSet.htm">EnvSet</a> 现在删除环境变量.</p>
<p>以前, 当脚本不是持续运行时, <a href="commands/Exit.htm">Exit</a> 作为 <a href="commands/ExitApp.htm">ExitApp</a> 使用, 即使有其他挂起的线程被调用 Exit 的线程打断. 现在它不再这样做了. 相反, 它总是正确地退出当前线程, 并且(如果不是持续运行的) 脚本只在最后一个线程退出后才终止. 这保证了 <code>finally</code> 语句的执行和局部变量的释放, 这可能允许对局部变量所包含的任何对象调用 <code>__delete</code> .</p>
<p><a href="commands/FileAppend.htm">FileAppend</a> 默认为没有行末转换, 与 <a href="commands/FileRead.htm">FileRead</a> 和 <a href="commands/FileOpen.htm">FileOpen</a> 一致. FileAppend 和 FileRead 都有一个单独的 <em>Options</em> 参数, 它取代了选项前缀, 并可能包括一个可选的编码名称(取代 FileRead 的 <code>*Pnnn</code> 选项). FileAppend, FileRead 和 FileOpen 使用 <code>"`n"</code> 来实现行末转换. FileAppend 和 FileRead 支持 <code>"RAW"</code> 选项来禁用编码转换(读/写二进制数据); FileRead 在这种情况下返回一个 <code>Buffer</code> 对象. 这取代了 <code>*c</code>(见文档中的 ClipboardAll). FileAppend 可以接受一个类 <code>Buffer</code> 对象, 在这种情况下不进行转换.</p>
<p>如果源路径不包含 <code>*</code> 或 <code>?</code> 并且没有找到文件, <a href="commands/FileCopy.htm">FileCopy</a> 和 <a href="commands/FileMove.htm">FileMove</a> 现在抛出异常. 然而, 当源路径包含通配符时, 复制或移动零个文件仍然不被视为错误.</p>
<p><a href="commands/FileOpen.htm">FileOpen</a> 现在如果它不能打开文件, 则抛出异常. 否则, 在第一次尝试访问对象时就会抛出异常(如果脚本没有检查失败), 而不是在实际的失败点抛出异常.</p>
<p><a href="objects/File.htm#RawRead">File.RawRead</a>: 当一个变量被直接传递时, 该变量的内部字符串缓冲的地址不再被使用. 因此, 一个包含地址的变量可以直接传递(而在 v1 版中, 类似 <code>var+0</code> 的东西是必须的).</p>
<p>对于由脚本分配的缓冲, 新的 <code>Buffer</code> 对象比变量更受欢迎; 可以使用任何对象, 但必须有 <code>Ptr</code> 和 <code>Size</code> 属性.</p>
<p><a href="objects/File.htm#RawWrite">File.RawWrite</a>: 和上面一样, 除了它可以接受一个字符串(或包含一个字符串的变量), 在这种情况下 <em>Bytes</em> 默认为字符串的字节大小. 字符串可以包含二进制的零.</p>
<p><a href="objects/File.htm#ReadLine">File.ReadLine</a> 现在总是支持 <code>`r</code>, <code>`n</code> 和 <code>`r`n</code> 作为行尾, 并且不再在返回值中包括行尾. 如果没有启用 EOL 转换, <a href="objects/File.htm#Read">File.Read</a> 仍会按原样返回给脚本.</p>
<p><a href="commands/FileEncoding.htm">FileEncoding</a> 现在允许用数字来指定代码页, 而不使用 <code>CP</code> 前缀.</p>
<p><a href="commands/FileExist.htm">FileExist</a> 现在忽略了每个目录列表中隐含的 <code>.</code> 和 <code>..</code>, 因此当目录存在但为空时, <code>FileExist("dir\*")</code> 现在是 false, 而不是 true.</p>
<p><a href="commands/FileGetAttrib.htm">FileGetAttrib</a> 和 A_LoopFileAttrib 现在对解析点或符号链接包含字母 "L".</p>
<p>如果源文件和目标文件是同一路径, 非编译脚本中的 <a href="commands/FileInstall.htm">FileInstall</a> 不再尝试复制文件(在解析了相对路径之后, 因为源文件相对于 <a href="Variables.htm#ScriptDir">A_ScriptDir</a>, 而不是 <a href="Variables.htm#WorkingDir">A_WorkingDir</a>). 在 v1 中, 这导致 ErrorLevel 被设置为 1, 这通常不会被注意到. 试图通过两个不同的路径将一个文件复制到自身仍然会导致错误. </p>
<p>FileSelectFile(现在名为 <a href="commands/FileSelect.htm">FileSelect</a>) 有两种多选模式, 可以通过选项 4 和 M 来访问. 选项 4 和相应的模式已经被删除; 它们已经有一段时间没有记录了. 当使用多选模式时, FileSelect 现在会返回一个路径的数组, 而不是像  <code>C:\Dir`nFile1`nFile2</code> 这样的字符串. 每个数组元素都包含一个文件的完整路径. 如果用户取消了, 数组就是空的.</p>
<p>FileSelect 现在使用 Windows Vista 及以后版本中的 IFileDialog API, 而不是以前的 GetOpenFileName/GetSaveFileName API. 这样就不需要使用与对话框改变当前工作目录有关的(内置) 解决方法.</p>
<p>当省略 <em>Filter</em> 时, FileSelect 默认不再有一个多余的 "Text Documents (*.txt)"/"文本文档(*.txt)" 过滤器.</p>
<p>FileSelect 不再从过滤器模式中剥离空格, 例如 <code>pattern with spaces*.ext</code> . 测试表明模式两侧的空格(例如 <code>*.cpp; *.h</code>) 中分号后的空格) 已经被操作系统忽略, 所以应该不会有负面影响.</p>
<p>FileSelect 现在可以通过 <code>D</code> 选项字母在 "选择文件夹" 模式下使用.</p>
<p><a href="commands/FileSetAttrib.htm">FileSetAttrib</a> 现在可以在没有 +, - 或 ^ 前缀的情况下覆盖属性, 而不是什么都不做. 例如, <code>FileSetAttrib(FileGetAttrib(file2), file1)</code> 将 file2 的属性复制到 file1 中(添加 file2 有的属性并删除其没有的属性).</p>
<p><a href="commands/FileSetAttrib.htm">FileSetAttrib</a> 和 <a href="commands/FileSetTime.htm">FileSetTime</a>: <em>OperateOnFolders?</em> 和 <em>Recurse?</em> 参数已被一个与 <a href="commands/LoopFiles.htm">Loop Files</a> 相同的 Mode 参数所取代. 例如, <code>FileSetAttrib("+a", "*.zip", "RF")</code>(只对 Files 进行递归操作).</p>
<p><a href="commands/GetKeyName.htm">GetKeyName</a>  现在返回 VK 代码的非 Numpad 名称, 这些名称对应于 Numpad 和非 Numpad 键. 例如, <code>GetKeyName("vk25")</code> 返回 Left, 而不是 NumpadLeft.</p>
<p><a href="commands/GetKeyState.htm">GetKeyState</a> 现在始终返回 0 或 1.</p>
<p><a href="commands/GroupActivate.htm">GroupActivate</a> 现在返回被选中激活的窗口的 HWND, 如果没有匹配的窗口(除了已经激活的窗口), 则返回 0, 而不是设置 ErrorLevel.</p>
<p><a href="commands/GroupAdd.htm">GroupAdd</a>: 删除了 <em>Label</em> 参数和相关功能. 这是一种不直观的方式, 用于检测 GroupActivate 未能找到任何匹配的窗口; 应该改为使用 <a href="commands/GroupActivate.htm">GroupActivate</a> 的返回值来代替.</p>
<p><a href="commands/GroupDeactivate.htm">GroupDeactivate</a> 现在以更接近 <kbd>Alt</kbd>+<kbd>Esc</kbd> 和 <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd> 系统热键和任务栏的方式选择窗口. 具体而言,</p>
<ul>
<li>不计算拥有的窗口. 如果所有者窗口符合条件(与组不匹配), 所有者窗口或其拥有的一个窗口被激活; 以最后激活的为准. 一个由组成员拥有的窗口将不再被激活, 但将拥有的窗口本身添加到组中现在没有任何影响. (以前的行为是循环浏览每个拥有的窗口, 而从不激活其所有者.)</li>
<li>任何被禁用的窗口都会被跳过, 除非其拥有的一个窗口最近比它更活跃.</li>
<li>具有 WS_EX_NOACTIVATE 风格的窗口被跳过, 因为它们可能不应该被激活. 它们也会被 <kbd>Alt</kbd>+<kbd>Esc</kbd> 和 <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd> 系统热键跳过.</li>
<li>具有 WS_EX_TOOLWINDOW 但不具有 WS_EX_APPWINDOW 的窗口被从任务栏和 Alt-Tab 中省略, 因此被跳过.</li>
</ul>
<p><a href="commands/Hotkey.htm">Hotkey</a> 不再默认为脚本中最底层 <a href="commands/_HotIf.htm">#HotIf</a>(以前是 <code>#If</code>). 热键/热字串和 HotIf 线程默认为与热键相同的条件, 因此 <code>Hotkey A_ThisHotkey, "Off"</code> 会关闭当前热键, 即使它是上下文相关的. 所有其他线程默认为自动执行部分使用的最后一个设置, 它本身默认为没有条件(全局热键).</p>
<p><a href="commands/Hotkey.htm">Hotkey</a> 的 <em>Callback</em> 参数现在需要一个函数对象或热键名称. 不再支持标签和函数名称. 如果指定了一个热键名称, 则使用该热键的原始函数; 而且与以前不同的是, 这与 <a href="commands/_HotIf.htm">#HotIf</a>(以前的 #If) 一起工作.</p>
<ul>
<li>其他好处, 这消除了以下特殊字符串的歧义: <code>On</code>, <code>Off</code>, <code>Toggle</code>, <code>AltTab</code>, <code>ShiftAltTab</code>, <code>AltTabAndMenu</code>, <code>AltTabMenuDismiss</code>. 以前的行为是使用该名称的标签/函数(如果存在的话), 但只有在 <em>Label</em> 参数不包含变量引用或表达式的情况下.</li>
</ul>
<p><a href="commands/Hotkey.htm">Hotkey</a> 和 <a href="commands/Hotstring.htm">Hotstring</a> 现在支持选项 S 以使热键/热串免于暂停 <a href="commands/Suspend.htm">Suspend</a>(相当于新的 <a href="commands/_SuspendExempt.htm">#SuspendExempt</a> 指令), 以及选项 S0 以禁止免于暂停.</p>
<p>"Hotkey If" 和其他 If 子命令被替换为单独的函数: <a href="commands/HotIf.htm">HotIf, HotIfWinActive, HotIfWinExist, HotIfWinNotActive, HotIfWinNotExist</a>.</p>
<p><a href="commands/HotIf.htm">HotIf</a>(以前的 "Hotkey If") 现在可以识别使用 <code>and</code> 或 <code>or</code> 运算符的表达式. 这在 v1 中不起作用, 因为这些运算符在加载时被替换为 <code>&amp;&amp;</code> 或 <code>||</code>.</p>
<p><a href="commands/Hotkey.htm">Hotkey</a> 不再有 <code>UseErrorLevel</code> 选项, 也不再设置 ErrorLevel. 失败时将抛出异常. 错误信息被改为恒定的(而且更短), 在 <code>Exception.Extra</code> 中包含了按键或热键的名称, 而异常的类别则表示失败的原因.</p>
<p><a href="commands/_HotIf.htm">#HotIf</a>(以前的 #If) 现在隐式地创建了带有参数(ThisHotkey) 的函数. 如同所有函数的默认情况一样, 这个函数是假设-本地的. 该表达式可以创建局部变量和读取全局变量, 但不能直接赋值给全局变量, 因为该表达式不能包含声明.</p>
<p><code>#HotIf</code> 已经被优化, 因此对 WinActive() 或 WinExist() 的简单调用可以由钩子线程直接计算(就像 <code>#IfWin</code> 在 v1 中一样, 而 <code>HotIfWin</code> 仍然是). 这提高了性能, 并减少了脚本繁忙/无响应时出现问题的风险. 该优化适用于包含对 WinActive() 或 WinExist() 的单次调用, 最多有两个参数的表达式, 其中每个参数是一个简单的带引号的字符串, 结果可以选择用 <code>!</code> 或 <code>not</code>. 例如, <code>#HotIf WinActive("Chrome")</code> 或 <code>#HotIf !WinExist("Popup")</code>. 在这些情况下, 具有任何给定标准组合的第一个表达式可以由表达式或窗口标准来确定. 例如, <code>HotIf '!WinExist("Popup")'</code> 和 <code>HotIfWinNotExist "Popup"</code> 指的是相同的热键变体.</p>
<p><code>KeyHistory N</code> 调整按键历史缓冲的大小, 而不是显示按键历史. 这取代了 "#KeyHistory N".</p>
<p><a href="commands/ImageSearch.htm">ImageSearch</a> 如果找到了图片, 则返回 true, 如果没有找到, 则返回 false, 如果不能进行搜索, 则抛出异常. 不设置 ErrorLevel.</p>
<p><a href="commands/IniDelete.htm">IniDelete</a>, <a href="commands/IniRead.htm">IniRead</a> 和 <a href="commands/IniWrite.htm">IniWrite</a> 设置 <a href="Variables.htm#LastError">A_LastError</a> 为操作系统的 GetLastError() 函数的结果.</p>
<p><a href="commands/IniRead.htm">IniRead</a> 抛出异常, 如果不能找到所请求的键, 段或文件, 并且省略了 <em>Default</em> 数. 如果 <em>Default</em> 被赋予一个值, 甚至是 <code>""</code>, 则不会抛出异常.</p>
<p><a href="commands/InputHook.htm">InputHook</a> 将 <kbd>Shift</kbd>+<kbd>Backspace</kbd> 视为 <kbd>Backspace</kbd>, 而不是把它转录为 <code>`b</code>.</p>
<p><a href="commands/InputBox.htm">InputBox</a> 进行了语法上的革新, 使其更容易使用(参数更少). 使用方法, 请参阅 <a href="#inputbox">InputBox</a>.</p>
<p><a href="commands/InStr.htm">InStr</a> 的 <em>CaseSensitive</em> 参数已被 <em>CaseSense</em> 替换, 它可以是 0, 1 或 "Locale".</p>
<p>现在, InStr 在 <em>Occurrence</em> 为负数时从右向左搜索(以前会导致结果为 0), 如果在 <em>Occurrence</em> 为正数时使用负的 <em>StartingPos</em> 则不再从右向左搜索. (然而, 如果 <em>StartingPos</em> 是负的, 而 <em>Occurrence</em> 是省略的, 它仍然从右向左搜索.) 这有利于在循环中进行从右到左的搜索, 并允许在使用负的 <em>StartingPos</em> 的同时仍然从左到右搜索.</p>
<ul>
<li>例如, <code>InStr(a, b,, -1, 2)</code> 现在从左到右搜索. 如果要从右向左搜索, 请使用 <code>InStr(a, b,, -1, -2)</code>.</li>
<li>注意 <em>StartingPos</em> 为 -1 意味着 v2 中的最后一个字符, v1 中的倒数第二个字符. 如果上面的例子来自 v1(而不是 v2.0-a033 - v2.0-a136), 新代码应该是 <code>InStr(a, b, -2, -2)</code>.</li>
</ul>
<p><a href="commands/KeyWait.htm">KeyWait</a> 现在如果等待期过了就返回 0, 否则返回 1. 删除了 ErrorLevel.</p>
<p><a href="commands/MouseClick.htm">MouseClick</a> 和 <a href="commands/MouseClickDrag.htm">MouseClickDrag</a> 不再受交换鼠标按钮的系统设置的影响; "Left" 始终是主按钮, 而 "Right" 是副按钮.</p>
<p><a href="commands/MsgBox.htm">MsgBox</a> 的语法发生了变化, 以优先考虑其最常用的参数, 并提高了易用性. 有关使用情况, 请参阅下面的 <a href="#msgbox">MsgBox</a>.</p>
<p><a href="commands/NumPut.htm">NumPut</a>/<a href="commands/NumGet.htm">NumGet</a>: 当直接传递变量时, 不再使用该变量的内部字符串缓冲的地址. 因此, 一个包含地址的变量可以直接传递(而在 v1 中, 类似 <code>var+0</code> 的东西是必须的). 对于由脚本分配的缓冲, 新的 <code>Buffer</code> 对象比变量更优先; 任何对象都可以使用, 但必须有 <code>Ptr</code> 和 <code>Size</code> 属性.</p>
<p>NumPut 的参数被重新排序, 以允许一连串的值, 每个数字前面都有(现在是强制性的) 类型字符串. 例如: <code>NumPut("ptr", a, "int", b, "int", c, addrOrBuffer, offset)</code>. 类型现在对于 NumGet 也是必须的. (与 DllCall 相比, NumPut 的输入参数对应于 dll 函数的参数, 而 NumGet 的返回类型参数对应于 dll 函数的返回类型字符串.)</p>
<p>使用 <code>Object(obj)</code> 和 <code>Object(ptr)</code> 在引用和指针之间的转换被转移到单独的函数, <code>ObjPtrAddRef(obj)</code> 和 <code>ObjFromPtrAddRef(ptr)</code>. 这些函数也有不增加引用计数的版本: <code>ObjPtr(obj)</code> 和 <code>ObjFromPtr(ptr)</code>.</p>
<p>OnClipboardChange 标签不再被自动调用, 如果它存在的话. 使用在 v1.1.20 版本中添加的 <a href="commands/OnClipboardChange.htm">OnClipboardChange</a> 函数来代替. 现在它需要一个函数对象, 而不是一个名称.</p>
<p><a href="commands/OnError.htm">OnError</a> 现在需要一个函数对象, 而不是一个名称. 另请参阅下面的: <a href="#error-handling">错误处理</a>.</p>
<p>OnExit 命令已被移除; 请使用 v1.1.20 中添加的 <a href="commands/OnExit.htm">OnExit</a> 函数. 现在它需要一个函数对象, 而不是一个名称. A_ExitReason 也被删除了; 它的值可以作为 OnExit 回调函数的一个参数使用.</p>
<p><a href="commands/OnMessage.htm">OnMessage</a> 不再具有传递函数名(字符串) 时使用的单函数每条消息模式; 它现在只接受一个函数引用. 使用 <code>OnMessage(x, MyFunc)</code> 其中 <em>MyFunc</em> 是原义上的函数名称, 但请注意, V1 的等价物是 <code>OnMessage(x, Func("MyFunc"))</code>, 允许其他函数继续监视消息 x, 这与 <code>OnMessage(x, "MyFunc")</code> 不同. 要停止监测消息, 请使用 <code>OnMessage(x, MyFunc, 0)</code>, 因为 <code>OnMessage(x, "")</code> 和 <code>OnMessage(x)</code> 现在是错误的. 失败时, OnMessage 抛出异常.</p>
<p>当在热键的第一行使用时, <a href="commands/Pause.htm">Pause</a> 不再豁免于 <a href="commands/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a>, 所以 <code>#p::Pause</code> 不再适用于切换暂停. 因此, <code>Pause()</code> 现在只暂停当前线程(对于像 ListVars/Pause 这样的组合), 而 <code>Pause(v)</code> 现在始终在底层线程上操作. <code>v</code> 必须是 0, 1 或 -1. 第二个参数被移除.</p>
<p><a href="commands/PixelSearch.htm">PixelSearch</a> 和 <a href="commands/PixelGetColor.htm">PixelGetColor</a> 使用 RGB 值而不是 BGR, 以便与其他函数保持一致. 如果出现问题, 这两个函数都会抛出异常, 并且不再设置 ErrorLevel. 如果找到了颜色, PixelSearch 返回 true. PixelSearch 的慢速模式已被删除, 因为它在大多数现代系统上是不可用的, 因为它与桌面合成不兼容.</p>
<p><a href="commands/PostMessage.htm">PostMessage</a>: 请参阅下面的 <a href="#SendMessage">SendMessage</a>.</p>
<p><a href="commands/Random.htm">Random</a> 已被重做, 以利用操作系统的随机数生成器, 取消了一些限制, 并使其使用起来更加方便.</p>
<ul>
<li>现在支持完整的 64 位有符号整数值范围(从 32 位增加).</li>
<li>浮点数由 53 位的随机整数生成, 而不是 32 位的随机整数, 并且应该大于或等于 Min 且小于 Max(但是浮点数的舍入误差理论上可以产生等于 Max 的结果).</li>
<li>这些参数已经可以以任何顺序指定, 但现在只指定第一个参数时, 会将其他边界默认为 0 而不是 2147483647. 例如, <code>Random(9)</code> 返回一个 0 到 9 之间的数字.</li>
<li>如果省略了两个参数, 则返回值是一个介于 0.0(包括) 和 1.0(一般不包括) 之间的浮点数, 而不是 0 和 2147483647(包括) 之间的整数.</li>
<li>系统会自动给随机数生成器播种, 不提供手动播种的方法, 所以无法替代 <em>NewSeed</em> 参数.</li>
</ul>
<p><a href="commands/RegExMatch.htm">RegExMatch</a> 选项 O 和 P 被删除; O(对象) 模式现在是强制性的. RegExMatch 对象现在支持枚举(for-loop). 匹配对象的语法已经改变:</p>
<ul>
<li>__Get 被用来实现速记的 <code>match.subpat</code> 其中 <em>subpat</em>  是一个子模式/捕获组的名称. 因为如果一个属性被 <em>inherited</em>, __Get 不再被调用, 以下的子模式名称不能再使用速记语法: Pos, Len, Name, Count, Mark. (例如, <code>match.Len</code> 总是返回整个匹配的长度, 而不是一个捕获的字符串.)</li>
<li>最初, 匹配对象有方法而不是属性, 这样属性就可以保留给子模式名称, 由于新的语言行为意味着 <code>match.name</code> 默认会返回一个函数, 方法已经被替换为或补充为属性:
<ul>
<li>Pos, Len 和 Name 现在是属性和方法.</li>
<li>Name 现在需要一个参数以避免混淆(<code>match.Name</code> 抛出一个错误).</li>
<li>Count 和 Mark 现在只是属性.</li>
<li>Value 已被删除; 使用 <code>match.0</code> 或 <code>match[]</code> 而不是 <code>match.Value()</code>, 和 <code>match[N]</code> 而不是 <code>match.Value(N)</code>.</li>
</ul>
</li>
</ul>
<p>RegisterCallback 被重命名为 <a href="commands/CallbackCreate.htm">CallbackCreate</a> 并被改为更好地利用闭包:</p>
<ul>
<li>它现在支持<a href="objects/Functor.htm">函数对象</a>(而不再支持函数名称).</li>
<li>删除了 EventInfo 参数(使用闭包或绑定函数代替).</li>
<li>删除了可变参回调函数的特殊行为, 并增加了 <code>&amp;</code> 选项(传递参数列表的地址).</li>
<li>增加了 <code>CallbackFree(Address)</code>, 以释放回调内存并释放关联的函数对象.</li>
</ul>
<p>注册表函数(<a href="commands/RegRead.htm">RegRead</a>, <a href="commands/RegWrite.htm">RegWrite</a>, <a href="commands/RegDelete.htm">RegDelete</a>): 在 v1.1.21+ 中增加的新语法现在是唯一的语法. 根键和子键被合并. 不写 <code>RootKey, Key</code>, 而写 <code>RootKey\Key</code>. 要连接到一个远程注册表, 使用 <code>\\ComputerName\RootKey\Key</code> 而不是 <code>\\ComputerName:RootKey, Key</code>.</p>
<p>RegWrite 的参数被重新排序, 像 IniWrite 一样把 <em>Value</em> 放在前面(但这并不影响单参数模式, 其中 <em>Value</em> 是唯一参数).</p>
<p>当 <em>KeyName</em> 被省略, 并且当前的循环注册项目是一个子键时; RegDelete, RegRead 和 RegWrite 现在对该子键内的值进行操作; 即在这种情况下, <em>KeyName</em> 默认为 <code>A_LoopRegKey "\" A_LoopRegName</code>(注意, A_LoopRegKey 与 A_LoopRegSubKey 合并了). 以前它们的表现如下:</p>
<ul>
<li>RegRead 读取一个与子键同名的值, 如果父键中存在这样的子键.</li>
<li>RegWrite 返回一个错误.</li>
<li>RegDelete 删除该子键.</li>
</ul>
<p>RegDelete, RegRead 和 RegWrite 现在允许在省略 <em>KeyName</em> 时指定 <em>ValueName</em>:</p>
<ul>
<li>如果当前循环注册表项是一个子键, <em>ValueName</em> 默认为空(子键的默认值) 并且必须指定 <em>ValueType</em>.</li>
<li>如果当前的循环注册表项是一个值, <em>ValueName</em> 和 <em>ValueType</em> 默认为该值的名称和类型, 但其中一个或两个可以被覆盖.</li>
</ul>
<p>否则, 带有空白或省略 <em>ValueName</em>的 RegDelete 现在会删除键的默认值(而不是键本身), 以便与 RegWrite, RegRead 和 A_LoopRegName 一致. 短语 "AHK_DEFAULT" 不再有任何特殊含义. 要删除一个键, 请使用 <a href="commands/RegDeleteKey.htm">RegDeleteKey</a>(新).</p>
<p><a href="commands/RegRead.htm">RegRead</a> 现在有一个 <em>Default</em> 参数, 像 IniRead 一样.</p>
<p>RegRead 有一个未记录的 5 参数模式, 即在输出变量之后指定值类型. 这已被删除.</p>
<p>如果脚本是从 stdin 读取的, 那么现在 <a href="commands/Reload.htm">Reload</a> 将不做任何事情.</p>
<p><a href="commands/Run.htm">Run</a> 和 <a href="commands/Run.htm">RunWait</a> 不再识别 <code>UseErrorLevel</code> 选项, 因为 ErrorLevel 已被删除. 使用 try/catch 代替. <a href="Variables.htm#LastError">A_LastError</a> 被无条件地设置, 并且可以在捕获/抑制异常后进行检查. RunWait 返回退出代码.</p>
<p><a href="commands/Send.htm">Send</a>(及其变体) 现在以一种与热键和 <a href="commands/Click.htm">Click</a> 一致的方式解释 <code>{LButton}</code> 和 <code>{RButton}</code>. 也就是说, LButton 是主按钮, RButton 是次按钮, 即使用户通过系统设置交换了这些按钮.</p>
<p id="SendMessage"><a href="commands/SendMessage.htm">SendMessage</a> 和 <a href="commands/PostMessage.htm">PostMessage</a> 现在要求 wParam 和 lParam 是整数或具有 Ptr 属性的对象; 如果它们被赋予一个非数字的字符串或浮点, 则抛出异常. 以前, 如果表达式以 <code>"</code> 开头, 则通过地址传递字符串, 但其他字符串被强制为整数. 传递一个变量的地址(以前是 <code>&amp;var</code>, 现在是 <code>StrPtr(var)</code>) 不再更新变量的长度(使用 <code>VarSetStrCapacity(&amp;var, -1)</code>).</p>
<p>SendMessage 和 PostMessage 现在在失败(或超时) 时抛出异常, 并且不设置 ErrorLevel. SendMessage 返回消息回复.</p>
<p><a href="commands/SetTimer.htm">SetTimer</a> 不再支持标签或函数名称, 但由于它现在接受表达式, 并且函数可以直接通过名称引用, 用法看起来非常相似: <code>SetTimer MyFunc</code>. 与所有其他接受对象的函数一样, SetTimer 现在允许返回对象的表达式(以前它需要一个变量引用).</p>
<p><a href="commands/Sort.htm">Sort</a> 得到了以下变化:</p>
<ul>
<li><em>VarName</em> 参数已被分成独立的输入/输出参数, 以增加灵活性. 现在的用法是  <code>Output := Sort(Input [, Options, Function])</code>.</li>
<li>当任何两个项目比较相等时, 项目的原始顺序将自动作为决定顺序的因素, 以确保结果更加稳定.</li>
<li><code>C</code> 选项现在也接受相当于其他函数的 <em>CaseSense</em> 参数的后缀(除 <code>CL</code> 外): <code>CLocale CLogical COn C1 COff C0</code>. 特别是, 对 "logical" 比较模式的支持是新加入的.</li>
</ul>
<p id="Sound"><a href="commands/Sound.htm">Sound 函数</a>: 修改了 SoundGet 和 SoundSet 以更好地匹配 Vista+ 声音 API 的功能, 放弃了对 XP 的支持.</p>
<ul>
<li>删除了不支持的控制类型.</li>
<li>删除了传统的混音器组件类型.</li>
<li>让组件通过名称和/或索引来引用.</li>
<li>让设备通过名称-前缀和/或索引来引用.</li>
<li>分成独立的音量和静音功能.</li>
<li>增加了 <a href="commands/SoundGetName.htm">SoundGetName</a> 用于检索设备或组件名称.</li>
<li>增加了 <a href="commands/SoundGetInterface.htm">SoundGetInterface</a> 用于检索 COM 接口.</li>
</ul>
<p><a href="commands/StrGet.htm">StrGet</a>: 如果 <em>Length</em> 是负数, 它的绝对值表示要转换的确切字符数, 包括字符串可能包含的任何二进制零值--换句话说, 结果总是一个正好是这个长度的字符串. 如果 <em>Length</em> 是正数, 转换后的字符串在第一个二进制 0 处结束, 就像在 v1 中一样.</p>
<p><a href="commands/StrGet.htm">StrGet</a>/<a href="commands/StrPut.htm">StrPut</a>: <em>Address</em> 参数可以是一个具有 <code>Ptr</code> 和 <code>Size</code> 属性的对象, 比如新的 <code>Buffer</code> 对象. 读/写会自动受到 <code>Size</code>(单位为字节) 的限制. 如果还指定了 <em>Length</em> 它不能超过 <em>Size</em>(对于 UTF-16 来说乘以 2).</p>
<p>StrPut 的返回值现在是以字节为单位, 所以它可以直接传递给 Buffer().</p>
<p><a href="commands/StrReplace.htm">StrReplace</a> 现在有一个 <em>CaseSense</em> 参数来代替 <em>OutputVarCount</em>, 它被移到了一个参数的右边, <em>Limit</em> 在它后面.</p>
<p><a href="commands/Suspend.htm">Suspend</a>: 在热键或热串的第一行调用 Suspend 不再自动使其免于挂起. 相反, 使用 <code>#SuspendExempt</code> 或 <code>S</code> 选项. "Permit" 参数值不再有效.</p>
<p><a href="commands/Switch.htm">Switch</a> 现在默认对字符串进行区分大小写的比较, 并且有一个 <em>CaseSense</em> 参数, 可以覆盖区分大小写的模式, 强制进行字符串(而不是数字) 比较. 以前, 只有当 StringCaseSense 被改为 On 时, 它才区分大小写.</p>
<p><a href="commands/SysGet.htm">SysGet</a> 现在只有数字子命令; 它的其他子命令已经被分割成函数. 有关详情, 请参阅<a href="#sub-commands">子命令</a>.</p>
<p>TrayTip 的用法已改为 <code>TrayTip [Text, Title, Options]</code>. <em>Options</em> 是一个由零个或多个不区分大小写的选项组成的字符串, 以空格或制表符分隔. 选项是 <code>Iconx</code>, <code>Icon!</code>, <code>Iconi</code>, <code>Mute</code> 和/或任何数值, 如以前一样. 即使省略了 <em>Text</em> 也会显示(现在比 V1 版更难意外地显示). <em>Seconds</em> 参数不再存在(它在 Windows Vista 或更高版本中没有作用). 脚本现在可以结合使用 NIIF_USER(0x4) 和 NIIF_LARGE_ICON(0x20) 标记 (0x24) 来在通知中包含大版本的托盘图标. NIIF_USER(0x4) 也可以单独用于小图标, 但无法在所有操作系统中产生一致的结果.</p>
<p>#Warn UseUnsetLocal 和 UseUnsetGlobal 已经被删除, 因为现在读取一个未设置的变量会抛出错误. 可以使用 <a href="commands/IsSet.htm">IsSet</a> 来避免错误, 也可以使用 <a href="commands/Try.htm">try</a>/<a href="commands/Catch.htm">catch</a> 或 <a href="commands/OnError.htm">OnError</a> 来处理它.</p>
<p>添加了 <a href="commands/_Warn.htm#VarUnset">#Warn VarUnset</a> 它默认为 MsgBox. 如果没有禁用, 在变量从未被用作直接的, 非动态的赋值或引用运算符(&amp;) 的目标, 或直接传递给 IsSet 时, 对于每个变量的第一个非动态引用会给出警告.</p>
<p><a href="commands/_Warn.htm#Unreachable">#Warn Unreachable</a> 不再认为 <code>Exit</code> 调用后的行是不可达的, 因为 Exit 现在是一个普通函数.</p>
<p>#Warn 已被删除, 因为顶级类不再被赋值所覆盖. (然而, 它们现在可以被一个局部变量隐式地覆盖; 这可以被 #Warn LocalSameAsGlobal 检测到.)</p>
<p><a href="commands/WinActivate.htm">WinActivate</a> 现在在第一次尝试激活一个窗口失败后会发送 <code>{Alt up}</code> 测试表明这减少了任务栏按钮闪烁的情况. 有关详情, 请参阅相关文档.</p>
<p><a href="commands/WinSetTitle.htm">WinSetTitle</a> 和 <a href="commands/WinMove.htm">WinMove</a> 现在使用与其他 Win 函数一致的参数顺序; 即 <em>WinTitle, WinText, ExcludeTitle, ExcludeText</em> 总是组合在一起(在参数列表的最后), 以帮助记忆.</p>
<p>各种函数的 <em>WinTitle</em> 参数现在可以接受一个 HWND(必须是纯整数) 或一个具有 <code>Hwnd</code> 性的对象, 如一个 Gui 对象. 在这种情况下, <code>DetectHiddenWindows</code> 会被忽略.</p>
<p><a href="commands/WinMove.htm">WinMove</a> 不再对原义单词 <code class="no-highlight">DEFAULT</code> 进行特殊处理. 省略该参数或指定一个空字符串代替(这适用于 v1 和 v2).</p>
<p><a href="commands/WinWait.htm">WinWait</a>, <a href="commands/WinWaitClose.htm">WinWaitClose</a>, <a href="commands/WinWaitActive.htm">WinWaitActive</a> 和 <a href="commands/WinWaitActive.htm">WinWaitNotActive</a> 在等待结束(超时未过) 时返回非零值). ErrorLevel 被删除. WinWait 和 WinWaitActive 返回找到的窗口的 HWND. WinWaitClose 现在设置了最后找到的窗口, 所以如果 WinWaitClose 超时, 它返回 false, <code>WinExist()</code> 返回最后找到的窗口. 对于超时, 指定 0 不再等同于指定 0.5; 相反, 它产生了尽可能短的等待.</p>
<p><strong>未分类:</strong></p>
<p><a href="commands/InStr.htm">InStr</a>, <a href="commands/SubStr.htm">SubStr</a>, <a href="commands/RegExMatch.htm">RegExMatch</a> 和 <a href="commands/RegExReplace.htm">RegExReplace</a> 的负的 <em>StartingPos</em> 被解释为从末尾开始的位置. 位置 -1 是最后一个字符, 位置 0 是无效的(而在 V1 中, 位置 0 是最后一个字符).</p>
<p>以前接受 On/Off 或 On/Off/Toggle(但不接受其他字符串) 的函数现在需要 1/0/-1 来代替. On 和 Off 通常会被替换成 <code>True</code> 和 <code>False</code>. 原先返回 On/Off 的变量现在返回 1/0, 这在表达式中更加有用.</p>
<ul>
<li><a href="commands/_UseHook.htm">#UseHook</a> 和 <a href="commands/_MaxThreadsBuffer.htm">#MaxThreadsBuffer</a> 允许 <code>1</code>, <code>0</code>, <code>True</code> 和 <code>False</code>.
(不像其他的, 它们实际上不支持表达式.)</li>
<li><a href="commands/ListLines.htm">ListLines</a> 允许空白或布尔值.</li>
<li><a href="commands/ControlSetChecked.htm">ControlSetChecked</a>, <a href="commands/ControlSetEnabled.htm">ControlSetEnabled</a>, <a href="commands/Pause.htm">Pause</a>, <a href="commands/Suspend.htm">Suspend</a>, <a href="commands/WinSetAlwaysOnTop.htm">WinSetAlwaysOnTop</a> 和 <a href="commands/WinSetEnabled.htm">WinSetEnabled</a> 允许 <code>1</code>, <code>0</code> 和 <code>-1</code>.</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a>, <a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a> 和 <a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> 使用布尔值(相应的函数也是如此).</li>
</ul>
<p>以下函数返回一个纯整数, 而不是十六进制字符串:</p>
<ul>
<li><a href="commands/ControlGetStyle.htm">ControlGetExStyle</a></li>
<li><a href="commands/ControlGetHwnd.htm">ControlGetHwnd</a></li>
<li><a href="commands/ControlGetStyle.htm">ControlGetStyle</a></li>
<li><a href="commands/MouseGetPos.htm">MouseGetPos</a></li>
<li><a href="commands/WinActive.htm">WinActive</a></li>
<li><a href="commands/WinExist.htm">WinExist</a></li>
<li><a href="commands/WinGetID.htm">WinGetID</a></li>
<li><a href="commands/WinGetIDLast.htm">WinGetIDLast</a></li>
<li><a href="commands/WinGetList.htm">WinGetList</a> (在数组中)</li>
<li><a href="commands/WinGetStyle.htm">WinGetStyle</a></li>
<li><a href="commands/WinGetStyle.htm">WinGetStyleEx</a></li>
<li><a href="commands/WinGetControlsHwnd.htm">WinGetControlsHwnd</a>(在数组中)</li>
</ul>
<p><a href="Variables.htm#ScriptHwnd">A_ScriptHwnd</a> 返回纯整数.</p>
<h4 id="dllcall">DllCall</h4>
<p>如果类型参数是变量, 该变量的内容总是被使用, 而不是它的名称. 换句话说, 不再支持不加引号的类型名 - 类型名必须用引号括起来.</p>
<p>当 DllCall 更新以 Str 或 Str 形式传递的变量的长度时, 它现在会检测字符串是否正确地空终止(可能表明发生了缓冲溢出), 如果是这样, 会以错误消息终止程序, 因为不能保证安全执行.</p>
<p><code>AStr</code>(没有任何后缀) 现在是只输入的. 因为缓冲永远只和输入字符串一样大, 所以它通常对输出参数没有用. 如果 AutoHotkey 被编译为 ANSI, 这将适用于 WStr 而不是 AStr, 但官方的 v2 版本只被编译为 Unicode.</p>
<p>如果一个函数向 <code>Str*</code>, <code>AStr*</code> 或 <code>WStr*</code> 参数写入一个新的地址, DllCall 现在会将新的字符串分配给相应的变量(如果有的话), 而不是仅仅更新原始字符串的长度(可能没有变化). 这种类型的参数通常不是用来修改输入的字符串, 而是在新的地址传回一个字符串.</p>
<p>DllCall 现在为任何 <code>Ptr</code> 参数和 <em>Function</em> 参数接受一个对象; 该对象必须有一个 <code>Ptr</code> 属性. 对于脚本分配的缓冲, 新的 <code>Buffer</code> 对象优先于变量. 对于 <code>Ptr*</code>, 参数的新值被分配回对象的 <code>Ptr</code> 属性. 这允许诸如 <code>DllCall(..., "Ptr*", unk := IUnknown.new())</code> 这样的结构, 与 <code>DllCall(..., "Ptr*", punk), unk := IUnknown.new(punk)</code> 相比, 减少了重复, 并且可以用来确保函数的任何输出被正确释放(即使由于 <code>HRESULT</code> 返回类型而抛出异常, 尽管通常在这种情况下函数不会输出一个非空指针).</p>
<p>DllCall 现在要求数字型参数的值必须是数字, 如果给出的是非数字或空字符串, 则会抛出异常. 特别是, 如果输出参数使用了 * 或 P 的后缀, 输出变量需要被初始化.</p>
<p>如果脚本传递一个包含数字的普通变量, 那么带有 * 或 P 后缀的数字参数的输出值(如果有的话) 会被忽略. 要接收输出值, 请传递一个 <code>VarRef</code>, 如 <code>&amp;myVar</code> 或一个具有 <code>Ptr</code> 属性的对象.</p>
<p>如果函数失败, 新的 <code>HRESULT</code> 返回类型会抛出异常(<code>int &lt; 0</code> 或 <code>uint &amp; 0x80000000</code>). 这应该只用于实际返回 <code>HRESULT</code> 的函数.</p>
<h4 id="loop-sub-commands">Loop 子命令</h4>
<p>子命令关键词必须按原义书写, 不能用引号括起来, 也不能是一个变量或表达式. 所有其他参数都是表达式. 所有循环子命令现在都支持 OTB.</p>
<p>已删除的:</p>
<pre class="no-highlight">Loop, FilePattern [, IncludeFolders?, Recurse?]
Loop, RootKey [, Key, IncludeSubkeys?, Recurse?]
</pre>
<p>使用下面的方法(在 v1.1.21 中添加) 来代替:</p>
<pre>Loop Files, FilePattern [, Mode]
Loop Reg, RootKey\Key [, Mode]
</pre>
<p>第二个单词后面的逗号现在是可选的.</p>
<p><a href="commands/LoopReg.htm#vars">A_LoopRegKey</a> 现在包含根键和子键, 而 A_LoopRegSubKey 已被删除.</p>
<h4 id="inputbox">InputBox</h4>
<pre>Obj := InputBox([Text, Title, Options, Default])
</pre>
<p><em>Options</em> 参数接受零个或多个不区分大小写的选项的字符串, 以空格或制表符为界, 类似于 Gui 控件选项. 例如, 这包括所有支持的选项: <code>x0 y0 w100 h100 T10.0 Password*</code>. <code>T</code> 是超时, 而 <code>Password</code> 的用法与同等的 Edit 控件选项相同.</p>
<p>宽度和高度选项现在可以设置客户端区域的大小(不包括标题栏和窗口框架的区域), 因此对主题的依赖性较小.</p>
<p>如果 <em>Title</em> 参数是一个空字符串, 标题将是空白的. 它只有在完全省略时才默认为 <a href="Variables.htm#ScriptName">A_ScriptName</a> 与用户定义函数的可选参数一致.</p>
<p><em>Obj</em> 是一个对象, 其属性是 <code>result</code>(包含 "OK", "Cancel" 或 "Timeout") 和 <code>value</code>.</p>
<h4 id="msgbox">MsgBox</h4>
<pre>Result := MsgBox([Text, Title, Options])
</pre>
<p><em>Options</em> 参数接受由零个或多个不区分大小写的选项组成的字符串, 以空格或制表符为界, 类似于 Gui 控件选项.</p>
<ul>
<li><code>Iconx</code>, <code>Icon?</code>, <code>Icon!</code> 和 <code>Iconi</code> 设置图标.</li>
<li><code class="no-highlight">Default</code> 后面紧跟一个整数, 设置第 <em>n</em> 个按钮为默认值.</li>
<li><code>T</code> 后面紧跟一个整数或浮点数, 设置超时, 单位是秒.</li>
<li><code>Owner</code> 后跟 HWND 设置所有者, 覆盖 <code>+OwnDialogs</code> 选项.</li>
<li>以下相互排斥的字符串之一设置按钮的选择: <code>OK</code>, <code>OKCancel</code>, <code>AbortRetryIgnore</code>, <code>YesNoCancel</code>, <code>YesNo</code>, <code>RetryCancel</code>, <code>CancelTryAgainContinue</code>, 或者只是用斜线分隔的首字母(<code>o/c</code>, <code>y/n</code>, 等等.), 或者只是没有斜线的首字母.</li>
<li>任何数字值, 与 v1 中的相同. 数字值可以与字符串选项相结合, 或者 <em>Options</em> 可以是纯整数.</li>
</ul>
<p>返回值是按钮的名称, 不带空格. 这些都是与 IfMsgBox 在 v1 中使用的字符串相同.</p>
<p>如果 <em>Title</em> 参数是一个空字符串, 标题将是空白. 只有当完全省略时, 它才默认为 <a href="Variables.htm#ScriptName">A_ScriptName</a>, 与用户定义的函数的可选参数一致.</p>
<h4 id="sub-commands">子命令</h4>
<p>Control, ControlGet, Drive, DriveGet, WinGet, WinSet 和 Process  的子命令已被替换为单独的函数, 而主命令已被删除. 一些函数的名称和用法已经改变. 新的用法如下所示:</p>
<pre><em>; 其中 ... 表示可选的 Control, WinTitle, 等等.</em>

Bool  := ControlGetChecked(...)
Bool  := ControlGetEnabled(...)
Bool  := ControlGetVisible(...)
Int   := ControlGetIndex(...)  ; 适用于 Tab, LB, CB, DDL
Str   := ControlGetChoice(...)
Arr   := ControlGetItems(...)
Int   := ControlGetStyle(...)
Int   := ControlGetExStyle(...)
Int   := ControlGetHwnd(...)

         ControlSetChecked(TrueFalseToggle, ...)
         ControlSetEnabled(TrueFalseToggle, ...)
         ControlShow(...)
         ControlHide(...)
         ControlSetStyle(Value, ...)
         ControlSetExStyle(Value, ...)
         ControlShowDropDown(...)
         ControlHideDropDown(...)
         ControlChooseIndex(Index, ...)  ; 同样涉及 Tab
Index := ControlChooseString(Str, ...)

Index := ControlFindItem(Str, ...)
Index := ControlAddItem(Str, ...)
           ControlDeleteItem(Index, ...)

Int   := EditGetLineCount(...)
Int   := EditGetCurrentLine(...)
Int   := EditGetCurrentCol(...)
Str   := EditGetLine(N [, ...])
Str   := EditGetSelectedText(...)
           EditPaste(Str, ...)

Str   := ListViewGetContent([Options, ...])

           DriveEject([Drive])
           DriveRetract([Drive])
           DriveLock(Drive)
           DriveUnlock(Drive)
           DriveSetLabel(Drive [, Label])

Str   := DriveGetList([Type])
Str   := DriveGetFilesystem(Drive)
Str   := DriveGetLabel(Drive)
Str   := DriveGetSerial(Drive)
Str   := DriveGetType(Path)
Str   := DriveGetStatus(Path)
Str   := DriveGetStatusCD(Drive)
Int   := DriveGetCapacity(Path)
Int   := DriveGetSpaceFree(Path)

<em>; 其中 ... 表示可选的 WinTitle, 等等.</em>

Int   := WinGetID(...)
Int   := WinGetIDLast(...)
Int   := WinGetPID(...)
Str   := WinGetProcessName(...)
Str   := WinGetProcessPath(...)
Int   := WinGetCount(...)
Array := WinGetList(...)
Int   := WinGetMinMax(...)
Array := WinGetControls(...)
Array := WinGetControlsHwnd(...)
Int   := WinGetTransparent(...)
Str   := WinGetTransColor(...)
Int   := WinGetStyle(...)
Int   := WinGetExStyle(...)

           WinSetTransparent(N [, ...])
           WinSetTransColor("Color [N]" [, ...]),
           WinSetAlwaysOnTop([TrueFalseToggle := -1, ...])
           WinSetStyle(Value [, ...])
           WinSetExStyle(Value [, ...])
           WinSetEnabled(Value [, ...])
           WinSetRegion(Value [, ...])

           WinRedraw(...)
           WinMoveBottom(...)
           WinMoveTop(...)

PID   := ProcessExist([PID_or_Name])
PID   := ProcessClose(PID_or_Name)
PID   := ProcessWait(PID_or_Name [, Timeout])
PID   := ProcessWaitClose(PID_or_Name [, Timeout])

         ProcessSetPriority(Priority [, PID_or_Name])
</pre>
<p><a href="commands/ProcessExist.htm">ProcessExist</a>, <a href="commands/ProcessClose.htm">ProcessClose</a>, <a href="commands/ProcessWait.htm">ProcessWait</a> 和 <a href="commands/ProcessWaitClose.htm">ProcessWaitClose</a> 不再设置 ErrorLevel; 相反, 它们返回 PID.</p>
<p>其他函数都不设置 ErrorLevel. 相反, 它们在失败时抛出异常. 在大多数情况下, 失败是因为没有找到目标窗口或控件.</p>
<p>HWND 和样式总是以纯整数形式返回, 而不是十六进制字符串.</p>
<p><a href="commands/ControlChooseIndex.htm">ControlChooseIndex</a> 允许 0 来取消对当前项目/所有项目的选择. 它取代了控件选择, 但也支持 Tab 控件.</p>
<p>ControlGet 被合并到 <a href="commands/ControlGetIndex.htm">ControlGetIndex</a>, 它也适用于 ListBox, ComboBox 和 DDL. 对于 Tab 控件, 如果没有选择 Tab, 它将返回 0(很少见, 但有效). <a href="commands/ControlChooseIndex.htm">ControlChooseIndex</a> 不允许 Tab 控件使用 0, 因为应用程序往往不会处理它.</p>
<p><a href="commands/ControlGetItems.htm">ControlGetItems</a> 取代了 ListBox 和 ComboBox 的 ControlGet List. 它返回一个数组.</p>
<p><a href="commands/DriveEject.htm">DriveEject</a> 和 <a href="commands/DriveEject.htm">DriveRetract</a> 现在使用 DeviceIoControl 而不是 mciSendString. DriveEject 能够弹出在资源管理器中有 "弹出" 选项的非 CD/DVD 驱动器(即可移动驱动器, 但不包括显示为固定磁盘的外部硬盘).</p>
<p><a href="commands/ListViewGetContent.htm">ListViewGetContent</a> 取代了 ListView 的 ControlGet List, 目前的用法与以前相同.</p>
<p><a href="commands/WinGetList.htm">WinGetList</a>, <a href="commands/WinGetControls.htm">WinGetControls</a> 和 <a href="commands/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> 返回数组, 而不是以新行分隔的列表.</p>
<p><a href="commands/WinSetTransparent.htm">WinSetTransparent</a> 将 "" 视为 "Off", 而不是 0(这将使窗口不可见且无法点击).</p>
<p>缩写的别名, 如 Topmost, Trans, FS 和 Cap 被删除.</p>
<p>以下函数以前是 <a href="commands/SysGet.htm">SysGet</a> 的子命令:</p>
<pre>Exists  := MonitorGet(N, Left, Top, Right, Bottom)
Exists  := MonitorGetWorkArea(N, Left, Top, Right, Bottom)
Count   := MonitorGetCount()
Primary := MonitorGetPrimary()
Name    := MonitorGetName(N)
</pre>
<h3 id="new-functions">新的函数</h3>
<p><code>Buffer(Size, FillByte)</code>(调用 Buffer 类) 创建并返回一个封装了 <em>Size</em> 字节的内存块的 <code>Buffer</code> 对象, 只在 <em>FillByte</em> 被指定时才初始化. <code>BufferObj.Ptr</code> 返回地址, 而 <code>BufferObj.Size</code> 返回或设置字节大小(重新分配内存块). 任何具有 Ptr 和 Size 属性的对象都可以传递给 <a href="commands/NumPut.htm">NumPut</a>, <a href="commands/NumGet.htm">NumGet</a>, <a href="commands/StrPut.htm">StrPut</a>, <a href="commands/StrGet.htm">StrGet</a>, <a href="objects/File.htm#RawRead">File.RawRead</a>, <a href="objects/File.htm#RawWrite">File.RawWrite</a> 和 <a href="commands/FileAppend.htm">FileAppend</a>. 任何具有 <code>Ptr</code> 属性的对象都可以被传递给 <a href="commands/DllCall.htm">DllCall</a> 的 <code>Ptr</code> 类型, <a href="commands/SendMessage.htm">SendMessage</a> 和 <a href="commands/PostMessage.htm">PostMessage</a> 参数.</p>
<p><code>CaretGetPos([&amp;X, &amp;Y])</code> 检索光标(文本插入点) 的当前坐标. 这确保了 X 和 Y 坐标总是匹配的, 并且没有缓存导致意外的行为(比如 A_CaretX/Y 返回一个不在当前 CoordMode 中的值).</p>
<p><code>ClipboardAll([Data, Size])</code> 创建一个包含剪贴板上所有内容的对象(可选择接受先前从剪贴板上获取的数据, 而不是使用剪贴板的当前内容). 读和写剪贴板文件数据的方法是不同的. 数据格式是一样的, 只是数据大小总是 32 位的, 这样数据就可以在 32 位和 64 位的构建之间移植. 详情见 v2 版文档.</p>
<p><code>ComCall(offset, comobj, ...)</code> 等同于 <code>DllCall(NumGet(NumGet(comobj.ptr) + offset * A_Index), "ptr", comobj.ptr, ...)</code>, 但返回类型默认为 "hresult", 而不是 "int".</p>
<p><a href="commands/ComObject.htm">ComObject</a>(以前是 ComObjCreate) 和 <a href="commands/ComObjQuery.htm">ComObjQuery</a> 现在返回一个包装对象, 即使指定了一个 IID. ComObjQuery 允许第一个参数是任何具有 <code>Ptr</code> 属性的对象.</p>
<p><a href="commands/ControlGetClassNN.htm">ControlGetClassNN</a> 返回指定控件的 ClassNN.</p>
<p><a href="commands/ControlSend.htm">ControlSendText</a> 等同于 ControlSendRaw 但使用 {Text} 模式而不是 {Raw} 模式.</p>
<p><code>DirExist(Path)</code> 用法类似于 FileExist. 注意 <code>InStr(FileExist(Pattern), "D")</code> 只告诉你 <em>第一个</em> 匹配的文件是否是一个文件夹, 而不是一个文件夹是否存在.</p>
<p><code>Float(v)</code>: 请参阅<a href="#types">类型</a>.</p>
<p><code>InstallKeybdHook(Install := true, Force := false)</code> 和 <code>InstallMouseHook(Install := true, Force := false)</code> 替换相应的指令, 为了提高稳定性.</p>
<p><code>Integer(v)</code>: 请参阅<a href="#types">类型</a>.</p>
<p id="isXXX"><a href="commands/Is.htm">isXXX</a>: 传统的命令 "if var is type" 已经被一系列的函数取代: isAlnum, isAlpha, isDigit, isFloat, isInteger, isLower, isNumber, isSpace, isUpper, isXDigit. 除了 isFloat, isInteger 和 isNumber 外, 如果参数不是字符串, 则会抛出异常, 因为隐式转换为字符串可能会导致反直觉的结果.</p>
<p><code>IsSet(var)</code>, <code>IsSetRef(&amp;var)</code>: 如果变量已经被分配了一个值(即使该值是一个空字符串), 则返回真, 否则返回假. 如果是 false, 试图在表达式中读取该变量会出现错误.</p>
<p><code>Menu()</code>/<code>MenuBar()</code> 返回一个新的 Menu/MenuBar 对象, 它有以下成员, 对应于 V1 Menu 子命令. 方法: <a href="objects/Menu.htm#Add">Add</a>, <a href="objects/Menu.htm#AddStandard"><strong>Add</strong>Standard</a>, <a href="objects/Menu.htm#Check">Check</a>, <a href="objects/Menu.htm#Delete">Delete</a>, <a href="objects/Menu.htm#Disable">Disable</a>, <a href="objects/Menu.htm#Enable">Enable</a>, <a href="objects/Menu.htm#Insert">Insert</a>, <a href="objects/Menu.htm#Rename">Rename</a>, <a href="objects/Menu.htm#SetColor"><strong>Set</strong>Color</a>, <a href="objects/Menu.htm#SetIcon"><strong>Set</strong>Icon</a>, <a href="objects/Menu.htm#Show">Show</a>, <a href="objects/Menu.htm#ToggleCheck">ToggleCheck</a>, <a href="objects/Menu.htm#ToggleEnable">ToggleEnable</a>, <a href="objects/Menu.htm#Uncheck">Uncheck</a>. 属性: <a href="objects/Menu.htm#ClickCount">Click<strong>Count</strong></a>, <a href="objects/Menu.htm#Default">Default</a>, <a href="objects/Menu.htm#Handle">Handle</a>(替换 MenuGetHandle). <a href="Variables.htm#TrayMenu">A_TrayMenu</a> 也返回一个菜单对象. 没有 UseErrorLevel 模式, 没有全局菜单名称, 也没有显式删除菜单本身(当所有引用被释放时就会发生; <a href="objects/Menu.htm#Delete">Delete</a> 等同于 v1 DeleteAll). 不支持标签, 只支持函数对象. <a href="objects/Menu.htm#AddStandard">AddStandard</a> 方法添加了标准的菜单项, 并允许它们像自定义项一样被单独修改. 与 v1 不同, Win32 菜单只有在对象被删除时才会被销毁.</p>
<p><code>MenuFromHandle(Handle)</code> 返回对应于 Win32 菜单句柄的菜单对象, 如果它是由 AutoHotkey 创建的.</p>
<p><code>Number(v)</code>: 请参阅上面的<a href="#types">类型</a>.</p>
<p><code>Persistent(Persist := true)</code> 替换相应的指令, 增加灵活性.</p>
<p><code>RegDeleteKey("RootKey\SubKey")</code> 删除一个注册表键. (RegDelete 现在只删除值, 除非在注册表循环中省略所有参数.)</p>
<p><a href="commands/Send.htm#SendText">SendText</a> 等同于 SendRaw, 但使用 {Text} 模式而不是 {Raw} 模式.</p>
<p><code>StrCompare(str1, str2 [, CaseSense := false])</code> 返回 -1(str1 小于 str2), 0(相等) 或 1(大于). <em>CaseSense</em> 可以是 "Locale".</p>
<p><code>String(v)</code>: 请参阅上面的<a href="#types">类型</a>.</p>
<p><code>StrPtr(str)</code> 返回字符串的地址. 与 v1 中的取址不同, 它可以用于原义字符串和临时字符串.</p>
<p><code>SysGetIPAddresses()</code> 返回一个 IP 地址的数组, 相当于已经被删除的 A_IPAddress 变量. 每个对 <code>A_IPAddress%N%</code> 的引用都会检索所有的地址, 但只返回一个, 所以检索多个地址所花费的时间是指数级的. 返回的数组可以有零个或多个元素. 
.</p>
<p><code>TraySetIcon([FileName, IconNumber, Freeze])</code> 替换 "Menu Tray, Icon".</p>
<p><code>VarSetStrCapacity(&amp;Var [, NewCapacity])</code> 取代了 V1 的 VarSetCapacity, 但只用于 UTF-16 字符串(如优化重复连接); 因此 <em>NewCapacity</em> 和返回值的单位是字符而不是字节.</p>
<p><code>VerCompare(A, B)</code> 使用与 <a href="commands/_Requires.htm">#Requires</a> 相同的算法对两个版本字符串进行比较.</p>
<p><code>WinGetClientPos([&amp;X, &amp;Y, &amp;W, &amp;H, WinTitle, ...])</code> 检索窗口客户端区域的位置和大小, 以屏幕坐标表示.</p>
<h3 id="new-directives">新的指令</h3>
<p><code>#DllLoad [FileOrDirName]</code>: 在脚本开始执行前加载一个 DLL 或 EXE 文件.</p>
<h3 id="built-in-variables">内置变量</h3>
<p><a href="Variables.htm#AhkPath">A_AhkPath</a> 总是返回当前可执行文件/解释器的路径, 即使脚本已被编译. 以前, 如果使用 BIN 文件作为基础文件, 它会返回编译后的脚本的路径, 但 V2.0 版本不再包括 BIN 文件.</p>
<p>如果脚本没有被编译, <a href="Variables.htm#IsCompiled">A_IsCompiled</a> 会返回 0 而不是 "".</p>
<p><a href="Variables.htm#OSVersion">A_OSVersion</a> 总是返回格式为 <code>major.minor.build</code> 的字符串, 例如 <code>6.1.7601</code> 对应于 Windows 7 SP1. 由于只支持基于 NT 的系统, 因此删除了 A_OSType.</p>
<p>当 <a href="Variables.htm#PriorHotkey">A_PriorHotkey</a> 为 "" 时, <a href="Variables.htm#TimeSincePriorHotkey">A_TimeSincePriorHotkey</a> 返回 "" 代替 -1 , 同样当 <a href="Variables.htm#ThisHotkey">A_ThisHotkey</a> 为空时, <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a> 返回空值.</p>
<p>所有内置的 "虚拟" 变量现在都有 <code>A_</code> 前缀(具体细节见下文). 任何没有这个前缀的预定义变量(比如 <code>Object</code>) 都只是全局变量. 这种区别可能很重要, 因为目前不可能对一个虚拟变量进行引用(除非直接传递给一个内置函数); 然而, <a href="Variables.htm#Args">A_Args</a> 不是一个虚拟变量.</p>
<p>返回数字的内置变量现在以<a href="Concepts.htm#numbers">整数</a>, 而不是<a href="Concepts.htm#strings">字符串</a>的形式返回.</p>
<p>重命名:</p>
<ul>
<li>A_LoopFileFullPath → <a href="commands/LoopFiles.htm#LoopFilePath">A_LoopFilePath</a> (如果 Loop 的参数是相对的, 则返回相对路径, 所以 "full path" 会产生误解)</li>
<li>A_LoopFileLongPath → <a href="commands/LoopFiles.htm#LoopFileFullPath">A_LoopFileFullPath</a></li>
<li>Clipboard → <a href="misc/A_Clipboard.htm">A_Clipboard</a></li>
</ul>
<p>删除的:</p>
<ul>
<li>ClipboardAll(使用 <a href="commands/ClipboardAll.htm">ClipboardAll</a> 函数代替)</li>
<li>ComSpec(使用 <a href="Variables.htm#ComSpec">A_ComSpec</a>)</li>
<li>ProgramFiles(使用 <a href="Variables.htm#ProgramFiles">A_ProgramFiles</a>)</li>
<li>A_AutoTrim</li>
<li>A_BatchLines</li>
<li>A_CaretX, A_CaretY(使用 <a href="commands/CaretGetPos.htm">CaretGetPos</a>)</li>
<li>A_DefaultGui, A_DefaultListView, A_DefaultTreeView</li>
<li>A_ExitReason</li>
<li>A_FormatFloat</li>
<li>A_FormatInteger</li>
<li>A_Gui, A_GuiControl, A_GuiControlEvent, A_GuiEvent, A_GuiX, A_GuiY, A_GuiWidth, A_GuiHeight(全部替换为<a href="objects/GuiOnEvent.htm">事件处理程序</a>的参数)</li>
<li>A_IPAddress1, A_IPAddress2, A_IPAddress3, A_IPAddress4(使用 <a href="commands/SysGetIPAddresses.htm">SysGetIPAddresses</a>)</li>
<li>A_IsUnicode(v2 总是 Unicode; 它可以替换为 <code>StrLen(Chr(0xFFFF))</code> 或用 <code>global A_IsUnicode := 1</code> 重新定义)</li>
<li>A_StringCaseSense</li>
<li>A_ThisLabel</li>
<li>A_ThisMenu, A_ThisMenuItem, A_ThisMenuItemPos(使用<a href="objects/Menu.htm#Add">菜单项回调的参数</a>)</li>
<li>A_LoopRegSubKey(<a href="commands/LoopReg.htm#vars">A_LoopRegKey</a> 现在包含根键和子键)</li>
<li>True 和 False(仍然存在, 但现在只是关键字, 而不是变量)</li>
</ul>
<p>新增:</p>
<ul>
<li><a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a>(读/写; 替换 "Menu Tray, MainWindow/NoMainWindow")</li>
<li><a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a>(替换 #HotkeyInterval)</li>
<li><a href="Variables.htm#HotkeyModifierTimeout">A_HotkeyModifierTimeout</a>(替换 #HotkeyModifierTimeout)</li>
<li><a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a>(请参阅下面的<a href="#default-settings">默认设置</a>)</li>
<li><a href="Variables.htm#MaxHotkeysPerInterval">A_MaxHotkeysPerInterval</a>(替换 #MaxHotkeysPerInterval)</li>
<li><a href="Variables.htm#MenuMaskKey">A_MenuMaskKey</a>(替换 #MenuMaskKey)</li>
</ul>
<p>以下内置变量可以被赋值:</p>
<ul>
<li><a href="Variables.htm#ControlDelay">A_ControlDelay</a></li>
<li><a href="Variables.htm#CoordMode">A_CoordMode..</a></li>
<li><a href="Variables.htm#DefaultMouseSpeed">A_DefaultMouseSpeed</a></li>
<li><a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a>(同样, 它现在返回 1 或 0, 而不是 "On" 或 "Off")</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a>(同样, 它现在返回 1 或 0, 而不是 "On" 或 "Off")</li>
<li><a href="Variables.htm#EventInfo">A_EventInfo</a></li>
<li><a href="Variables.htm#FileEncoding">A_FileEncoding</a>(同样, 它现在返回 "CP0" 代替 "", 并允许在赋值时省略 "CP" 前缀)</li>
<li><a href="Variables.htm#IconHidden">A_IconHidden</a></li>
<li><a href="Variables.htm#IconTip">A_IconTip</a>(同样, 它现在总是反映 tooltip, 即使它是默认的或空的)</li>
<li><a href="Variables.htm#Index">A_Index</a>: 对于计数的循环, 修改它将影响执行多少次迭代. (内置变量的全局性质意味着枚举器函数可以设置索引, 以便 For 循环查看.)</li>
<li><a href="Variables.htm#KeyDelay">A_KeyDelay</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDelayPlay</a></li>
<li><a href="Variables.htm#KeyDelay">A_KeyDuration</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDurationPlay</a></li>
<li><a href="Variables.htm#LastError">A_LastError</a>: 调用 Win32 SetLastError() 函数. 同样, 它现在返回一个无符号值.</li>
<li><a href="Variables.htm#ListLines">A_ListLines</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelay</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelayPlay</a></li>
<li><a href="Variables.htm#RegView">A_RegView</a></li>
<li><a href="Variables.htm#ScriptName">A_ScriptName</a>: 更改默认的对话框标题.</li>
<li><a href="Variables.htm#SendLevel">A_SendLevel</a></li>
<li><a href="Variables.htm#SendMode">A_SendMode</a></li>
<li><a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a>(同样, 它现在返回 1 或 0, 而不是 "On" 或 "Off")</li>
<li><a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a></li>
<li><a href="Variables.htm#TitleMatchModeSpeed">A_TitleMatchModeSpeed</a></li>
<li><a href="Variables.htm#WinDelay">A_WinDelay</a></li>
<li><a href="Variables.htm#WorkingDir">A_WorkingDir</a>: 等同于调用 <a href="commands/SetWorkingDir.htm">SetWorkingDir</a>.</li>
</ul>
<h3 id="built-in-objects">内置对象</h3>
<p>现在, 文件对象在调用属性时严格要求使用属性语法, 在调用方法时严格要求使用方法语法. 例如, <code>File.Pos(n)</code> 是无效的. 如果参数太少或太多, 或者只读属性被赋值, 则抛出异常.</p>
<p><code>File.Tell()</code> 被删除.</p>
<p><code>Func.IsByRef()</code> 现在可以与内置函数一起工作.</p>
<h2 id="gui">Gui</h2>
<p>Gui, GuiControl 和 GuiControlGet 被 <a href="objects/Gui.htm#Call">Gui()</a> 和 <a href="objects/Gui.htm">Gui</a>/<a href="objects/GuiControl.htm">GuiControl</a> 对象所取代, 它们通常更灵活, 更一致, 更容易使用.</p>
<p>GUI 通常不是通过名字/数字编号来引用的(尽管它仍然可以用 <code>GuiObj.Name</code> 命名). 相反, GUI 对象(和窗口) 是通过实例化 <code>Gui</code> 类显式创建的, 如 <code>GuiObj := Gui()</code>. 这个对象具有取代 Gui 子命令的方法和属性. <code>GuiObj.Add()</code> 返回一个 GuiControl 对象, 该对象具有替代 GuiControl 和 GuiControlGet 命令的方法和属性. 人们可以将这个对象存储在一个变量中, 或者使用 <code>GuiObj["Name"]</code> 或 <code>GuiCtrlFromHwnd(hwnd)</code> 来检索这个对象. 每当调用一个事件处理程序(g-label 的替换) 时, 它也会作为一个参数被传递.</p>
<p>这些方法和属性的用法不是 1:1. 许多部分已经被修改, 以使其更加一致和灵活, 并修复错误或限制.</p>
<p>没有 "默认" GUI, 因为目标 Gui 或控制对象总是被指定的. LV/TV/SB 函数被替换为(控件对象的) 方法, 使得使用多个 ListViews/TreeViews 更加容易.</p>
<p>没有包含事件信息的内置变量. 这些信息被作为参数传递给处理事件的函数/方法, 包括源 Gui 或控件.</p>
<p>控件仍然可以被命名, 并且可以通过名字来引用, 但它只是一个名称(与 <code>GuiObj["Name"]</code> 和 <code>GuiObj.Submit()</code> 一起使用), 而不是一个关联变量, 所以不需要声明或创建一个全局或静态变量. 该值绝不会自动存储在变量中, 而是通过 <code>GuiCtrl.Value</code> 进行访问. <code>GuiObj.Submit()</code> 返回一个以控件名称作为键的新关联数组.</p>
<p>v<em>Name</em> 选项现在只是将控件的名称设置为 <em>Name</em>.</p>
<p>+Hwnd<em>VarName</em> 选项已被删除, 改为使用 <code>GuiCtrl.Hwnd</code>.</p>
<p>不再有 "g-labels" 或标签/函数来自动处理 GUI 事件. 脚本必须通过调用 Gui 或 GuiControl 的 <a href="objects/GuiOnEvent.htm">OnEvent</a> 方法来注册每个感兴趣的事件. 例如, 脚本不会在 g-label 中检查 <code>if (A_GuiEvent = "I" &amp;&amp; InStr(ErrorLevel, "F", true))</code>, 脚本将为 <code>ItemFocus</code> 事件注册处理程序: <code>MyLV.OnEvent("ItemFocus", MyFunction)</code>. <em>MyFunction</em> 将仅为 ItemFocus 事件调用. 没有必要应用 <code>AltSubmit</code> 来启用其他事件.</p>
<p>数组被用于以前使用管道分隔的列表的地方, 例如在创建 ListBox 时, 在添加项目时, 或在检索选定的项目时, 为 ListBox 指定项目.</p>
<p>脚本可以定义一个 <code>extends Gui</code> 的类, 并处理它自己的事件, 使所有的 GUI 逻辑自成一体.</p>
<h3 id="gui-sub-commands">Gui 子命令</h3>
<p><strong>Gui New</strong> → <a href="objects/Gui.htm#Call">Gui()</a>. 传递空标题(不省略) 现在会导致空标题, 而不是默认标题.</p>
<p><strong>Gui Add</strong> → <a href="objects/Gui.htm#Add">GuiObj.Add() 或 GuiObj.Add<em>ControlType</em>()</a>; 例如 <code>GuiObj.Add("Edit")</code> 或 <code>GuiObj.AddEdit()</code>.</p>
<p><strong>Gui Show</strong> → <a href="objects/Gui.htm#Show">GuiObj.Show()</a>, 但它没有 <em>Title</em> 参数. 标题可以由 Gui() 的参数或通过 GuiObj.Title 属性来指定. 初始焦点仍然设置为具有 WS_TABSTOP 样式的第一个可输入控件(根据系统的默认消息处理), 除非是 Button 控件, 在这种情况下, 焦点现在转移到 Default(默认) 按钮上.</p>
<p><strong>Gui Submit</strong> → <a href="objects/Gui.htm#Submit">GuiObj.Submit()</a>. 除了 Submit() 创建并返回一个包含所有 "关联变量" 的新对象之外, 它的工作方式与以前类似.</p>
<p><strong>Gui Destroy</strong> → <a href="objects/Gui.htm#Destroy">GuiObj.Destroy()</a>. 该对象仍然存在(直到脚本释放它), 但不能使用. 必须创建新的 GUI(如果需要). 删除对象时, 窗口也会被销毁, 但当窗口可见时, 该对象将 "保持活动状态".</p>
<p><strong>Gui Font</strong> → <a href="objects/Gui.htm#SetFont">GuiObj.SetFont()</a>. 也可以使用 GuiCtrl.SetFont() 直接设置控件的字体.</p>
<p><strong>Gui Color</strong> → <a href="objects/Gui.htm#BackColor">GuiObj.BackColor</a> 设置/返回背景颜色. 不支持 <em>ControlColor</em>(第二个参数), 但所有以前支持它的控件都可以使用 <code>+Background</code> 选项来设置背景. 与 Gui Color 不同, GuiObj.BackColor 不会影响 Progress 控件或禁用的/只读的 Edit, DDL, ComboBox 或 TreeView(带有 -Theme) 控件.</p>
<p><strong>Gui Margin</strong> → <a href="objects/Gui.htm#MarginX">GuiObj.MarginX</a> 和 <a href="objects/Gui.htm#MarginY">GuiObj.MarginY</a> 属性.</p>
<p><strong>Gui Menu</strong> → <a href="objects/Gui.htm#MenuBar">GuiObj.MenuBar</a> 设置/返回使用 <code>MenuBar()</code> 创建的 MenuBar 对象.</p>
<p><strong>Gui Cancel/Hide/Minimize/Maximize/Restore</strong> → 使用同名的 Gui 方法.</p>
<p><strong>Gui Flash</strong> → <a href="objects/Gui.htm#Flash">GuiObj.Flash()</a>, 但使用 <code>false</code> 代替 <code>Off</code>.</p>
<p><strong>Gui Tab</strong> → <a href="objects/GuiControl.htm#UseTab">TabControl.UseTab()</a>. 与以前一样, 默认匹配选项卡名称的前缀. 对于第二个参数传递 true 以匹配整个选项卡名称, 但与 v1 "Exact" 模式不同, 它不区分大小写.</p>
<h3 id="events">事件</h3>
<p>关于所有显式支持的 GUI 和 GUI 控件事件的细节, 请参阅<a href="objects/GuiOnEvent.htm#Events">事件(OnEvent)</a>.</p>
<p>Size 事件传递 0, -1 或 1(与 <a href="commands/WinGetMinMax.htm">WinGetMinMax</a> 一致) 而不是 0, 1 或 2.</p>
<p>ContextMenu 事件可以为每个控件注册, 也可以为整个 GUI 注册.</p>
<p>DropFiles 事件交换了 <em>FileArray</em> 和 <em>Ctrl</em> 参数, 以便与 ContextMenu 一致.</p>
<p>ContextMenu 和 DropFiles 事件使用客户端坐标, 而不是窗口坐标(Client 也是 v2 中的默认的 <a href="commands/CoordMode.htm">CoordMode</a>).</p>
<p>删除了以下控件事件, 但检测它们只需将适当的数字通知代码(在 Windows SDK 中定义) 传递给 <a href="objects/GuiOnNotify.htm">GuiCtrl.OnNotify()</a> 即可: K, D, d, A, S, s, M, C, E 和 MonthCal 的 1 和 2.</p>
<p>Control 事件不传递事件名称作为参数(GUI 事件从未传递过).</p>
<p>自定义的 N 和 Normal 事件被 <a href="objects/GuiOnNotify.htm">GuiCtrl.OnNotify()</a> 和 <a href="objects/GuiOnCommand.htm">GuiCtrl.OnCommand()</a> 取代, 它们可以用于任何控件.</p>
<p>Link 的 Click 事件传递 "Ctrl, ID 或 Index, HREF", 而不是 "Ctrl, Index, HREF 或 ID", 如果注册了 Click 回调, 则不会自动执行 HREF.</p>
<p>ListView 的 Click, DoubleClick 和 ContextMenu(当由右键触发时) 事件现在报告被点击的项目(如果没有则为 0), 而不是焦点项目.</p>
<p>ListView 的 I 事件被拆分为多个命名事件, 除了 f(取消焦点)事件, 因为它被 F(ItemFocus) 所隐含, 所以被排除.</p>
<p>ListView 的 e(ItemEdit) 事件在用户取消时被忽略.</p>
<p>Slider 的 Change 事件比 V1 的 g-label 事件更稳定地被引发; 也就是说, 它不再默认忽略鼠标滚轮的变化. 有关详情, 请参阅<a href="commands/GuiControls.htm#slider-change">检测更改(Slider)</a>.</p>
<p>BS_NOTIFY 样式现在会根据需要自动添加到 Button, CheckBox 和 Radio 控件. 它不再被默认应用于 Radio 控件.</p>
<p>Focus(以前的 F) 和 LoseFocus(以前的 f) 支持更多的(但不是全部) 控件类型.</p>
<p>使用 Edit.Value 或 Edit.Text 设置 Edit 控件的文本不会触发该控件的 Change 事件, 而 GuiControl 会触发该控件的 g-label.</p>
<p>LV/TV.Add/Modify 现在抑制了项目变更事件, 所以这类事件只能由用户操作或 SendMessage 引发.</p>
<h3 id="removed">删除的</h3>
<p>+Delimiter<br>
+Hwnd<em>OutputVar</em> (使用 <a href="objects/Gui.htm#Hwnd">GuiObj.Hwnd</a> 或 <a href="objects/GuiControl.htm#Hwnd">GuiCtrl.Hwnd</a> 代替)<br>
+Label<br>
+LastFoundExist<br>
Gui GuiName: Default</p>
<h3 id="control-options">控件选项</h3>
<p>对 +/-Background 的解释和支持更加一致. 所有支持 "Gui Color" 的控件现在都支持 <code>+Background<i>Color</i></code> 和 <code>+BackgroundDefault</code>(<code>-Background</code> 相同), 而不仅仅是 ListView/TreeView/StatusBar/Progress.</p>
<p>当使用 <code>xp</code>/<code>yp</code> 或 <code>xp+0</code>/<code>yp+0</code> 时, <a href="objects/Gui.htm#Add">GuiObj.Add</a> 默认为 <code>y+m</code>/<code>x+m</code>, 而不是 <code>yp</code>/<code>xp</code>. 换句话说, 控件被放置在前一个控件的下面/右边, 而不是在完全相同的位置. 如果使用非零偏移, 行为与 v1 相同. 要使用完全相同的位置, 请同时指定 <code>xp yp</code>.</p>
<p><code>x+m</code> 和 <code>y+m</code> 后面可以跟一个额外的偏移量, 如 <code>x+m+10</code>(<code>x+m10</code> 也是有效的, 但可读性差).</p>
<p><code>Choose</code> 不再是指定 MonthCal 值的一个多余的(无文档) 方式. 就像以前一样, 使用 <em>Text</em> 参数.</p>
<h3 id="guicontrolget">GuiControlGet</h3>
<h4 id="empty-sub-command">空子命令</h4>
<p>GuiControlGet 的空子命令有两种模式: 默认模式和文本模式, 其中第四个参数是单词 <code>Text</code>. 如果控件类型没有单一的 "value", GuiControlGet 默认为返回 <a href="https://msdn.microsoft.com/library/ms633520">GetWindowText</a> 的结果(不一定是可见文本). 有些控件没有可见文本, 或者不支持检索它, 所以完全忽略了第四个参数. 相比之下, <a href="objects/GuiControl.htm#Text">GuiCtrl.Text</a> 会返回显示文本, 隐藏文本(与 ControlGetText 返回的文本相同) 或者什么都没有.</p>
<p>下表显示了 GuiControlGet 的每种模式和控件类型的最接近的等价属性或函数.</p>
<table class="info">
<tr><th>控件</th><th>默认</th><th>文本</th><th>注意</th></tr>
<tr><td>ActiveX</td><td>.Value</td><td>.Text</td><td>文本处于隐藏状态. 见下文.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Text</td><td>ControlGetText()</td><td>如果使用了 AltSubmit, 请使用 Value 而不是 Text(但如果 Text 与列表项目不匹配,则 Value 返回 0). Text 执行大小写更正, 而 ControlGetText 返回 Edit 区域的内容.</td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Text</td><td>如果使用了 AltSubmit, 请使用 Value 而不是 Text.</td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td>.Text</td><td>ControlGetText()</td><td>如果使用了 AltSubmit, 请使用 Value 而不是 Text. Text 返回所选项目的文本, 而 ControlGetText 返回隐藏文本. 见下文.</td></tr>
<tr><td>ListView</td><td colspan="2">.Text</td><td>文本处于隐藏状态.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Tab</td><td>.Text</td><td>ControlGetText()</td><td>如果使用了 AltSubmit, 请使用 Value 而不是 Text. Text 返回所选选项卡的文本, 而 ControlGetText 返回隐藏文本.</td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">.Text</td><td>文本处于隐藏状态.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td></td></tr>
</table>
<p>ListBox: 对于多选 ListBox, Text 和 Value 返回数组, 而不是管道分隔的列表.</p>
<p>ActiveX: <a href="objects/GuiControl.htm#Value">GuiCtrl.Value</a> 每次都会返回相同的对象, 而 GuiControlGet 每次都会创建一个新的封装对象. 因此, 为了保持 <a href="commands/ComObjConnect.htm">ComObjConnect</a> 连接处于活动状态, 不再需要保留对 ActiveX 对象的引用.</p>
<h4 id="other-sub-commands">其他子命令</h4>
<p><strong>Pos</strong> → <a href="objects/GuiControl.htm#GetPos">GuiCtrl.GetPos()</a></p>
<p><strong>Focus</strong> → <a href="objects/Gui.htm#FocusedCtrl">GuiObj.FocusedCtrl</a>; 返回一个 GuiControl 对象而不是 ClassNN.</p>
<p><strong>FocusV</strong> → <code>GuiObj.FocusedCtrl.Name</code></p>
<p><strong>Hwnd</strong> → <a href="objects/GuiControl.htm#Hwnd">GuiCtrl.Hwnd</a>; 返回一个纯整数, 而不是十六进制的字符串.</p>
<p><strong>Enabled/Visible/Name</strong> → 同名的 GuiCtrl 属性.</p>
<h3 id="guicontrol">GuiControl</h3>
<h4 id="blank-and-text-sub-commands">(空) 和 Text 子命令</h4>
<p>下表显示了 GuiControl 的每种模式和控件类型的最接近的等效属性或函数.</p>
<table class="info">
<tr><th>控件</th><th>(Blank)</th><th>Text</th><th>注意</th></tr>
<tr><td>ActiveX</td><td colspan="2">N/A</td><td>命令没有效果.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Delete/Add/Choose</td><td>.Text</td><td></td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td>.Value</td><td>.SetFormat()</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>ListView</td><td colspan="2">N/A</td><td>命令没有效果.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td>使用 <code>+=</code> 运算符代替 <code>+</code> 前缀.</td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td>使用 <code>+=</code> 运算符代替 <code>+</code> 前缀.</td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text 或 SB.SetText()</td><td></td></tr>
<tr><td>Tab</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">N/A</td><td>命令没有效果.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td>使用 <code>+=</code> 运算符代替 <code>+</code> 前缀.</td></tr>
</table>
<h4 id="other-sub-commands-1">其他子命令</h4>
<p><strong>Move</strong> → <a href="objects/GuiControl.htm#Move">GuiCtrl.Move(x, y, w, h)</a></p>
<p><strong>MoveDraw</strong> → GuiCtrl.Move(x, y, w, h), <a href="objects/GuiControl.htm#Redraw">GuiCtrl.Redraw()</a></p>
<p><strong>Focus</strong> → <a href="objects/GuiControl.htm">GuiCtrl.Focus()</a>, 现在使用 WM_NEXTDLGCTL 而不是 SetFocus, 因此聚焦 Button 可以暂时将其设置为默认值, 这与制表时的控件一致.</p>
<p><strong>Enable/Disable</strong> → set <a href="objects/GuiControl.htm#Enabled">GuiCtrl.Enabled</a></p>
<p><strong>Hide/Show</strong> → set <a href="objects/GuiControl.htm#Visible">GuiCtrl.Visible</a></p>
<p><strong>Choose</strong> → <a href="objects/GuiControl.htm#Choose">GuiCtrl.Choose(n)</a>, 其中 n 为纯整数. 不支持 <code>|n</code> 或 <code>||n</code> 模式(如果需要, 使用 ControlChoose 代替).</p>
<p><strong>ChooseString</strong> → <a href="objects/GuiControl.htm#Choose">GuiCtrl.Choose(s)</a>, 其中 s 不是一个纯整数. 不支持 <code>|n</code> 或 <code>||n</code> 模式. 如果字符串与多选列表框中的多个项目匹配, Choose() 将全部选择, 而不是只选择第一个.</p>
<p><strong>Font</strong> → <a href="objects/GuiControl.htm#SetFont">GuiCtrl.SetFont()</a></p>
<p><strong>+/-Option</strong> → <a href="objects/GuiControl.htm#Opt">GuiCtrl.Opt("+/-Option")</a></p>
<h3 id="other-changes">其他更改</h3>
<p>Progress Gui 控件不再具有默认的 PBS_SMOOTH 样式, 因此它们现在是根据系统的视觉样式来设计的.</p>
<p>当 DPI 大于 100% 时, 默认的边距和控件尺寸(尤其是 Button 控件) 可能与 v1 版略有不同.</p>
<p>当图片控件无法通过 <code>GuiCtrl.Value := "new image.png"</code> 设置新图片时, 不再删除当前图片. 但是, 允许通过 <code>GuiCtrl.Value := ""</code> 删除当前图像.</p>
<h2 id="error-handling">错误处理</h2>
<p>在退出脚本之前, <a href="commands/OnError.htm">OnError</a> 现在被调用来处理关键性的错误. 尽管脚本可能不处于安全的执行状态, 但仍会进行尝试, 这与 OnExit 一致.</p>
<p>运行时错误不再将 <code>Exception.What</code> 设置为当前正在运行的用户定义的函数或子函数(但在调用 <code>Error()</code> 时仍会这样做, 但没有第二个参数). 这给了 <code>What</code> 一个更明确的目的: 函数名称表示该函数的失败(而不是调用该函数或计算其参数的失败). 对于表达式计算和控制流错误, <code>What</code> 是空白的(其他一些也可能是空白).</p>
<p>由运行时错误抛出的异常对象现在可以被识别为新的 Error 类或更具体的子类的实例. Error 对象有一个 <code>Stack</code> 属性, 包含一个堆栈跟踪. 如果 <em>What</em> 参数指定了一个正在运行的函数的名称, 那么现在会根据哪一行调用该函数来设置 <em>File</em> 和 <em>Line</em> .</p>
<p>Try-catch 语法已经改变, 允许脚本捕捉特定的错误类, 而不捕捉其他错误. 有关详情, 请参阅下文的 <a href="#catch">Catch</a> 章节.</p>
<h3 id="continuable-errors">可继续错误(不中断脚本运行)</h3>
<p>在大多数情况下, 错误对话框现在提供了继续当前线程的选项(而不是退出线程). COM 错误现在在选择不继续时退出线程(而不是退出整个脚本).</p>
<p>脚本不应依赖于此. 如果错误是由一个内置函数引发的, 继续会导致它返回 "". 如果错误是由表达式计算器引发的(比如无效的动态引用或除以 0), 表达式会被中止, 并返回 ""(如果用作控制流语句的参数).</p>
<p>在某些情况下, 代码不支持继续, 继续的选项不应该被显示. 对于旨在终止脚本的关键错误, 也不显示该选项.</p>
<p><a href="commands/OnError.htm">OnError</a> 回调现在接受第二个参数, 包含以下值之一:</p>
<ul>
<li>"Return": 返回 -1 将继续执行线程, 而 0 和 1 则和以前一样.</li>
<li>"Exit": 不支持继续执行. 返回非零将停止进一步的处理, 但仍然退出线程.</li>
<li>"ExitApp": 这是一个关键错误. 返回非零值会停止进一步的处理, 但脚本仍然被终止.</li>
</ul>
<h3 id="errorlevel">ErrorLevel</h3>
<p>ErrorLevel 已经被删除. 脚本经常(也许通常) 是在没有错误检查的情况下编写的, 所以为错误设置 ErrorLevel 的策略经常让它们不被检测到. 即时的错误信息可能看起来有点对抗性, 但通常更有帮助.</p>
<p>在以前设置 ErrorLevel 以指示错误情况的地方, 会抛出异常, 并有一个(通常) 更有用的错误信息.</p>
<p>诸如 "Process Exist" 之类的命令使用它来返回一个值, 现在只是返回这个值(例如 <code>pid := ProcessExist()</code>) 或更有用的东西(例如 <code>hwnd := GroupActivate(group)</code>).</p>
<p>在某些情况下, ErrorLevel 被用于辅助返回值.</p>
<ul>
<li>使用 U 选项的 <a href="commands/Sort.htm">Sort</a> 不再返回删除的重复数.</li>
<li><code>Input</code> 被删除. 它被 InputHook 所取代. 几行代码可以做一个简单的替换, 返回一个包含结果的 InputHook 对象, 而不是使用 ErrorLevel 和一个 OutputVar.</li>
<li><a href="commands/InputBox.htm">InputBox</a> 返回一个带有 <code>result</code>(OK, Cancel 或 Timeout) 和 <code>value</code> 属性的对象.</li>
</ul>
<p>以前在 ErrorLevel 中存储失败次数的文件函数现在在抛出的异常对象的 <code>Extra</code> 属性中抛出它.</p>
<p><a href="commands/SendMessage.htm">SendMessage</a> 超时通常是一种异常情况, 所以会导致抛出 <code>TimeoutError</code>. <code>TargetError</code> 和 <code>OSError</code> 可能会在其他条件下被抛出.</p>
<p><a href="commands/Run.htm">Run</a> 和 <a href="commands/Hotkey.htm">Hotkey</a> 函数的 <code>UseErrorLevel</code> 模式被移除. 这种模式早于 <code>Try</code>/<code>Catch</code> 添加到语言中. 菜单和 Gui 也有这种模式, 但被替换为对象(不使用 ErrorLevel).</p>
<h3 id="expressions-1">表达式</h3>
<p>与 v1 相比, 更多的语法错误会引发加载时错误, 如:</p>
<ul>
<li>空括号(与函数名相邻的除外); 例如 <code>x ()</code></li>
<li>前缀运算符使用错误或缺少操作数; 例如 <code>x!</code></li>
<li>少于两个操作数的二元运算符.</li>
<li>少于三个操作数的三元运算符.</li>
<li>赋值的目标不是一个可写的变量或属性.</li>
</ul>
<p>当发生以下任何故障时, 会抛出异常(而不是忽略该故障或产生一个空字符串):</p>
<ul>
<li>试图对一个非数字值进行数学运算. (数字字符串是可以的.)</li>
<li>除以 0 或其他无效/不支持的输入, 如 <code>(-1)**1.5</code>. 注意, 有些情况会被新检测为无效, 如 <code>0**0</code> 和 <code>a&lt;&lt;b</code> 或 <code>a&gt;&gt;b</code>, 其中 <code>b</code> 的范围不在 0..63.</li>
<li>未能为内置函数的返回值, 串联或表达式的结果分配内存.</li>
<li>堆栈下溢(通常由语法错误引起).</li>
<li>试图向不是变量(或数组元素) 的东西赋值.</li>
<li>试图向一个只读变量赋值.</li>
<li>试图用一个空的名称进行双重解引, 如 <code>fn(%empty%)</code>.</li>
<li>未能执行动态函数调用或方法调用.</li>
<li>一个方法/属性调用失败, 因为该值没有实现该方法/属性. (对于 v1 中的关联数组, 只有方法调用可以导致这种情况.)</li>
<li>由于内存分配失败而导致对象分配失败.</li>
</ul>
<p>上面的一些条件在 v1 中被检测到, 但在表达式中间没有被检测到; 例如, <code>A_AhkPath := x</code> 在 v1 中检测到, 但在 v2 中仅在 <code>y := x, A_AhkPath := x</code> 检测到.</p>
<p>独立使用运算符 <code>+=</code>, <code>-=</code>, <code>--</code> 和 <code>++</code> 不再将空变量视为 0. 这与 v1 不同, 在 v1 中, 独立使用运算符时将空变量视为 0, 但在表达式中间或与多语句逗号一起使用时则不会.</p>
<h3 id="functions-1">函数</h3>
<p>函数在失败时通常会抛出异常. 特别是:</p>
<ul>
<li>
<p>由于 <a href="commands/DllCall.htm">DllCall</a>, <a href="commands/RegExMatch.htm">RegExMatch</a> 和 <a href="commands/RegExReplace.htm">RegExReplace</a> 的不正确使用导致的错误由于其复杂性而相当常见, 而且(像许多错误一样) 如果立即显示错误信息, 则更容易发现和调试.</p>
</li>
<li>
<p>如果<a href="commands/Math.htm">数学函数</a>的任何输入不是数字, 或者操作无效(如除以 0), 则抛出异常.</p>
</li>
<li>
<p>带有 <em>WinTitle</em> 参数的函数(有例外, 如 <a href="commands/WinClose.htm">WinClose</a> 的 ahk_group 模式), 如果没有找到目标窗口或控件就会抛出.</p>
</li>
</ul>
<p>对一些以前没有检测到的错误抛出了异常, 一些被错误地标记为错误的情况(以前是通过设置 ErrorLevel) 被修复.</p>
<p>某些 error 消息已经发生变化.</p>
<h3 id="catch">Catch</h3>
<p><a href="commands/Catch.htm">Catch</a> 的语法已经更改, 以提供一种方法来捕获特定的错误类, 而不捕获其他的错误(将控制权转移到调用堆栈更上层的另一个 Catch, 或报告错误并退出线程). 以前这需要捕捉所有类型的抛出值, 然后检查类型并重新抛出. 例如:</p>
<pre><em>; 旧的(使用废弃的 v2.0-a 规则进行演示, 因为 v1 没有 `is` 或 Error 类)</em>
try
    SendMessage msg,,, "Control1", "The Window"
catch err
    if err is TimeoutError
        MsgBox "The Window is unresponsive"
    else
        throw err

<em>; 新的</em>
try
    SendMessage msg,,, "Control1", "The Window"
catch TimeoutError
    MsgBox "The Window is unresponsive"
</pre>
<p>变化:</p>
<ul>
<li><code>catch</code> 捕获一个错误实例.</li>
<li><code>catch as err</code> 捕捉一个 Error 实例, 它被分配给 err.</li>
<li><code>catch ValueError as err</code> 捕捉一个 ValueError 实例, 它被分配给 err.</li>
<li><code>catch ValueError, TypeError</code> 捕捉任一类型错误.</li>
<li><code>catch ValueError, TypeError as err</code> 捕获任一类型错误并将实例分配给 err.</li>
<li><code>catch Any</code> 捕捉 anything.</li>
<li><code>catch (MyError as err)</code> 允许使用括号, 就像大多数其他控制流语句一样.</li>
</ul>
<p>如果使用 <code>try</code> 而不使用 <code>finally</code> 或 <code>catch</code> 它的行为就像有一个空块的 <code>catch</code> 虽然这听起来像 v1, 但现在 <code>catch</code> 本身只抓取 <code>Error</code> 的实例. 在大多数情况下, <code>try</code> 本身就是为了抑制一个 Error, 所以不需要做任何改变. 然而, v2 中与 v1 <code>try something()</code> 直接等价的是:</p>
<pre>try something()
catch Any
{}
</pre>
<p>优先考虑错误类型而不是输出变量名称可能会鼓励更好的代码; 按照预期处理预期的错误, 而不是压制或错误地处理本应报告的意外错误.</p>
<p>由于所有类型的值都可以被抛出, 任何类对过滤器来说都是有效的(例如 <code>String</code> 或 <code>Map</code>). 然而, 类的原型在加载时被解析, 必须被指定为一个完整的类名, 而不是一个任意的表达式(类似于 <code>class x extends y</code> 中的 <code>y</code>).</p>
<p>当 <code>catch</code> 语句正在执行时, <code>throw</code> 可以在没有参数的情况下被用来重新抛出异常(避免了为此目的指定一个输出变量的需要). 这甚至在嵌套的 <code>try</code>...<code>finally</code> 中也被支持, 但在嵌套的 <code>try</code>...<code>catch</code> 中不支持. <code>throw</code> 不需要被 <code>catch</code> 语句的主体所包含; 它可以被一个被调用的函数所使用.</p>
<p>在最后一个 <code>catch</code> 之后可以有一个 <code>else</code>; 如果在 <code>try</code> 中没有抛出异常, 就执行它.</p>
<h2 id="keyboard-mouse-hotkeys-and-hotstrings">键盘, 鼠标, 热键和热字串</h2>
<p>更少的 VK 到 SC 和 SC 到 VK 的映射是硬编码的, 在理论上提高了与非常规的自定义键盘布局的兼容性.</p>
<p>删除了 "Return" 和 "Break" 键的名称. 使用 "Enter" 和 "Pause" 代替.</p>
<p>现在总是通过从键盘布局 DLL 读取 KLLF_ALTGR 标志来检测每个键盘布局上是否存在 <kbd>AltGr</kbd>. (v1.1.28+ 版本已经使用了这种方法.) 通过键盘钩子检测 <kbd>AltGr</kbd> 的后备方法已经被删除.</p>
<p>鼠标滚轮热键将 <a href="Variables.htm#EventInfo">A_EventInfo</a> 设置为由鼠标驱动程序报告的滚轮延迟, 而不是除以 120. 一般来说, 它是 120 的倍数, 但一些鼠标硬件/驱动程序可能会以更高的分辨率报告滚轮运动.</p>
<p>热串现在将 <kbd>Shift</kbd>+<kbd>Backspace</kbd> 视为 <kbd>Backspace</kbd>, 而不是在热串缓冲内将其转录为 <code>`b</code>.</p>
<p>热字串使用第一对冒号(<code class="no-highlight">::</code>) 作为分隔符, 而不是在出现多对冒号时使用最后一对. 换句话说, 在 v2 中, 冒号(与另一个冒号相邻时) 必须在触发文本中转义, 而在 v1 中, 它们必须在替换中转义. 请注意, 对于奇数的连续冒号, 以前的行为不认为最后的冒号是一对冒号的一部分. 例如, 对于 <code class="no-highlight">::1:::2</code>(<code class="no-highlight">1</code> → <code class="no-highlight">:2</code>) 的行为没有变化, 但 <code class="no-highlight">::3::::4</code> 现在是 <code class="no-highlight">3</code> → <code class="no-highlight">::4</code> 而不是 <code class="no-highlight">3::</code> → <code class="no-highlight">4</code>.</p>
<p>热字串不再成对转义冒号, 这意味着现在可以在热串触发器的末尾转义一个冒号. 例如, <code class="no-highlight">::5`:::6</code> 现在是 <code class="no-highlight">5:</code> → <code class="no-highlight">6</code> 而不是一个错误, 而 <code class="no-highlight">::7`::::8</code> 现在是 <code class="no-highlight">7:</code> → <code class="no-highlight">:8</code> 而不是 <code class="no-highlight">7::</code> → <code>8</code>. 在这些情况下, 最好转义每个原义的冒号, 以避免混淆(但单个孤立的冒号不需要转义).</p>
<p>带有延续片段的热字串现在默认为文本模式而不是原始模式.</p>
<p>热键现在只在 Win/Alt 键在逻辑上是向下的并且热键需要 Win/Alt 键(带 <code>#</code>/<code>!</code> 或自定义前缀) 的情况下才会在释放时屏蔽. 也就是说, 不需要 Win/Alt 键的热键在 Win/Alt 键物理上处于关闭状态时不再掩盖 Win/Alt 向上. 这使得发送 <code>{Blind}{LWin up}</code> 的热键可以激活开始菜单(如果使用 <code>AppsKey::RWin</code> 这样的重映射键, 这已经是可能的).</p>

<h2 id="other">其他</h2>
<p>已放弃对 Windows 2000 和 Windows XP 的支持.</p>
<p>AutoHotkey 不再在启动时覆盖系统的 <code>ForegroundLockTimeout</code> 设置.</p>
<ul>
<li>这是通过调用带有 <code>SPI_SETFOREGROUNDLOCKTIMEOUT</code> 的 <code>SystemParametersInfo</code> 动作实现的, 它影响到当前用户会话的所有应用程序. 它在注销后不会持续存在, 但对一些用户来说仍是不受欢迎的.</li>
<li>用户的错误报告(和常识) 表明, 如果它起作用, 它允许焦点被那些没有专门设计的程序窃取.</li>
<li>在 Windows 10 上的一些测试表明, 它对任何事情都没有影响; 对 <code>SetForegroundWindow</code> 的调用总是失败的, 而 WinActivate 采用的其他变通方法是需要的, 并且无论超时与否都是有效的. <code>SPI_GETFOREGROUNDLOCKTIMEOUT</code> 是从一个单独的进程中使用的, 以验证该变化是否生效(它有时并不生效).</li>
<li>它可以很容易地在脚本中被复制:
<pre>DllCall("SystemParametersInfo", "int", 0x2001, "int", 0, "ptr", 0, "int", 2)</pre>
</li>
</ul>
<p>RegEx 换行匹配默认为 (*ANYCRLF) 和 (*BSR_ANYCRLF); `r 和 `n 被识别, 除了 `r`n 之外. `a 选项隐含地启用了 (*BSR_UNICODE).</p>
<p>正则调出现在可以是可变的. 通过 <code>pcre_callout</code> 变量指定的调出可以是任何可调用的对象, 或 <code>pcre_callout</code> 本身可以直接定义为函数(可能是嵌套函数). 随着函数和变量<a href="#scope">命名空间的合并</a>, 诸如 <code>(?C:fn)</code> 这样的调出模式也可以指代包含函数对象的局部或全局变量, 而不仅仅是用户定义的函数.</p>
<p>从 stdin 读取的脚本(例如用 <code>AutoHotkey.exe *</code>) 不再包括 <a href="Variables.htm#ScriptFullPath">A_ScriptFullPath</a> 中的初始工作目录或主窗口的标题, 但它被用作 <a href="Variables.htm#ScriptDir">A_ScriptDir</a> 和定位本地 Lib 文件夹.</p>
<p>由自动执行线程改变的设置现在会立即成为默认设置(对于在此后启动的线程), 而不是在 100ms 后, 当自动执行线程结束时再变成默认设置.</p>
<p>通过利用动态分配, 以下限制已被取消:</p>
<ul>
<li>行或延续片段最大长度为 16383 个字符.</li>
<li>每个表达式最大 512 个标记(MAX_TOKENS).<br>
基于 MAX_TOKENS 确定大小的表达式计算器的内部数组现在是基于预先计算的所需大小的估计值, 因此性能应该是相似的, 但在大多数情况下堆栈的使用量会低一些. 这可能会增加用户定义的函数的最大递归深度.</li>
<li>每个参数最多可以引用 512 个 var 或函数(但无论如何, MAX_TOKENS 对表达式的限制更大).</li>
<li>每个函数最多可以调用 255 个指定的参数值(但无论如何 MAX_TOKENS 更有限制性).</li>
</ul>
<p><a href="commands/ListVars.htm">ListVars</a> 现在将静态变量与局部变量分开显示. 在函数中声明的全局变量也被列为静态变量(这是新的实现细节的副作用, 但被保留下来, 因为它在有许多全局变量的脚本中可能是有用的).</p>
<p>为了减少代码大小和维护成本, 删除了(未记录的) "lazy var". 这个优化改进了有超过 100,000 个变量的脚本的性能.</p>
<p><a href="Program.htm#tray-icon">托盘菜单</a>: 从 "Reload This Script" 和 "Edit This Script" 中删除了 "This", 以便与 "Pause Script" 和主窗口的菜单选项一致.</p>
<p>如果时间戳长度不是 4 到 14(包括) 之间的偶数, YYYYMMDDHH24MISS 时间戳值现在被认为是无效的.</p>
<h3 id="persistence">持续运行</h3>
<p>当至少满足以下条件之一时, 脚本 "<a href="commands/Persistent.htm">持续运行</a>":</p>
<ul>
<li>至少有一个热键或热字符串被脚本定义.</li>
<li>至少有一个 <a href="objects/Gui.htm">Gui</a>(或脚本的<a href="Program.htm#main-window">主窗口</a>) 可见.</li>
<li>至少有一个脚本的<a href="commands/SetTimer.htm">定时器</a>目前是启用的.</li>
<li>至少有一个 <a href="commands/OnClipboardChange.htm">OnClipboardChange</a> 的回调函数已经被设置.</li>
<li>至少有一个 <a href="commands/InputHook.htm">InputHook</a> 是激活的.</li>
<li>调用了 <code>Persistent()</code> 或 <code>Persistent(true)</code> 并且没有通过调用 <code>Persistent(false)</code> 来反转.</li>
</ul>
<p>如果出现以下情况之一, 并且没有满足以上条件, 那么脚本就会终止.</p>
<ul>
<li>最后一个脚本线程结束了.</li>
<li><a href="objects/Gui.htm">Gui</a> 被关闭或销毁.</li>
<li>脚本的<a href="Program.htm#main-window">主窗口</a>被关闭(但销毁它将导致脚本退出, 而不考虑持续运行, 如前所述).</li>
<li>一个没有 <a href="commands/InputHook.htm#OnEnd">OnEnd</a> 回调的 <a href="commands/InputHook.htm">InputHook</a> 结束.</li>
</ul>
<p>为了灵活起见, <a href="commands/OnMessage.htm">OnMessage</a> 并不能使脚本自动持续运行.</p>
<p>相比之下, 当以下情况中至少有一个为真时, v1 脚本就会 "持续运行":</p>
<ul>
<li>至少有一个热键或热字串被脚本定义.</li>
<li>Gui 或 OnMessage() 出现在脚本的任何地方.</li>
<li>键盘钩子或鼠标钩子已被安装.</li>
<li>Input 已经被调用.</li>
<li>#Persistent 已经被使用.</li>
</ul>
<h3 id="threads">线程</h3>
<p><a href="misc/Threads.htm">线程</a>开始时的不间断超时为 17ms, 而不是 15ms. 15 太短了, 因为系统的 tick 计数是以 15 或 16 为最小单位更新的; 也就是说, 如果 tick 计数正好在错误的时刻更新, 线程就可能成为可中断的, 尽管几乎没有时间过去.</p>
<p>线程在开始时是不可中断的, 现在则保持这种状态, 直到至少执行了一行, 即使不可中断的超时时间首先到期(例如, 如果系统在线程开始后立即暂停进程, 以便将 CPU 时间给另一个进程).</p>
<p><a href="commands/_MaxThreads.htm">#MaxThreads</a> 和 <a href="commands/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> 不再对任何第一行是下列函数之一的子程序设置异常: <a href="commands/ExitApp.htm">ExitApp</a>, <a href="commands/Pause.htm">Pause</a>, <a href="commands/Edit.htm">Edit</a>, <a href="commands/Reload.htm">Reload</a>, <a href="commands/KeyHistory.htm">KeyHistory</a>, <a href="commands/ListLines.htm">ListLines</a>, <a href="commands/ListVars.htm">ListVars</a> 或 <a href="commands/ListHotkeys.htm">ListHotkeys</a>.</p>
<h3 id="default-settings">默认设置</h3>
<ul>
<li>#NoEnv 是默认行为, 所以该指令本身已经被删除. 如果等效的内置变量不可用, 请使用 <a href="commands/EnvGet.htm">EnvGet</a> 代替.</li>
<li><a href="commands/SendMode.htm">SendMode</a> 默认为输入(Input) 而不是事件(Event).</li>
<li><a href="commands/SetTitleMatchMode.htm">标题匹配模式</a>默认为 2 而不是 1.</li>
<li>删除了 SetBatchLines, 因此所有脚本都以全速运行(等同于 v1 中的 SetBatchLines -1).</li>
<li>工作目录默认为 <a href="Variables.htm#ScriptDir">A_ScriptDir</a>. <a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> 包含由启动 AutoHotkey 的进程设置的工作目录.</li>
<li><a href="commands/_SingleInstance.htm">#SingleInstance</a> 提示行为对所有脚本来说都是默认的; #SingleInstance 本身就会激活强制模式. <code>#SingleInstance Prompt</code> 也可以显式地使用, 以达到清晰的目的, 或者覆盖之前的指令.</li>
<li><a href="commands/CoordMode.htm">CoordMode</a> 默认为 Client(在 v1.1.05 版中加入), 而不是 Window.</li>
<li>脚本文件(但不包括 <em>由</em> 脚本读取的文件) 的默认编码现在是 UTF-8 而不是 ANSI(CP0). 和以前一样, 这可以通过 /CP 命令行开关来覆盖.</li>
</ul>
<h3 id="command-line">命令行</h3>
<p>命令行参数不再存储在一个编号化的伪数组全局变量中; 应该使用全局变量 <a href="Variables.htm#Args">A_Args</a>(在 v1.1.27 中添加) 来代替.</p>
<p>删除了 /R 和 /F 开关. 使用 /restart 和 /force 代替.</p>
<p>当 AutoHotkey.exe 被用来检查脚本的语法错误时, 应该使用 /validate 来代替 /iLib, 因为函数库的自动包含机制被移除.</p>
<p>在以下任一情况下, /ErrorStdOut 现在被视为脚本的参数之一, 而不是内置的:</p>
<ul>
<li>当脚本是编译的, 除非使用了 /script.</li>
<li>当它的后缀不是以 <code>=</code> 开头时(以前后缀是被忽略的).</li>
</ul>

</body>
</html>